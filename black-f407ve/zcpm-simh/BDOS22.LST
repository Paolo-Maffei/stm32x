Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   1
BDOS22  Z80

    1                   ;**************************************************************
    2                   ;*
    3                   ;*             C P / M   version   2 . 2
    4                   ;*
    5                   ;*   Reconstructed from memory image on February 27, 1981
    6                   ;*
    7                   ;*                by Clark A. Calkins
    8                   ;*
    9                   ;**************************************************************
   10                   ;
   11                   ;   Set memory limit here. This is the amount of contigeous
   12                   ; ram starting from 0000. CP/M will reside at the end of this space.
   13                   ;
   14                   
   15         0003      IOBYTE   EQU    3               ;i/o definition byte.
   16         0004      TDRIVE   EQU    4               ;current drive name and user number.
   17         0005      ENTRY    EQU    5               ;entry point for the cp/m bdos.
   18         005C      TFCB     EQU    5CH             ;default file control block.
   19         0080      TBUFF    EQU    80H             ;i/o buffer and command line storage.
   20         0100      TBASE    EQU    100H            ;transiant program storage area.
   21                   ;
   22                   ;   Set control character equates.
   23                   ;
   24         0003      CNTRLC   EQU    3               ;control-c
   25         0005      CNTRLE   EQU    05H             ;control-e
   26         0008      BS       EQU    08H             ;backspace
   27         0009      TAB      EQU    09H             ;tab
   28         000A      LF       EQU    0AH             ;line feed
   29         000C      FF       EQU    0CH             ;form feed
   30         000D      CR       EQU    0DH             ;carriage return
   31         0010      CNTRLP   EQU    10H             ;control-p
   32         0012      CNTRLR   EQU    12H             ;control-r
   33         0013      CNTRLS   EQU    13H             ;control-s
   34         0015      CNTRLU   EQU    15H             ;control-u
   35         0018      CNTRLX   EQU    18H             ;control-x
   36         001A      CNTRLZ   EQU    1AH             ;control-z (end-of-file mark)
   37         007F      DEL      EQU    7FH             ;rubout
   38                   ;
   39                   ;   Set origin for CP/M
   40                   ;
   41         E800               ORG    0E800H
   42                   ;
   43 E800  C3 EB5C     CBASE:  JP      COMMAND         ;execute command processor (ccp).
   44 E803  C3 EB58             JP      CLEARBUF        ;entry to empty input buffer before starting ccp.
   45                   
   46                   ;
   47                   ;   Standard cp/m ccp input buffer. Format is (max length),
   48                   ; (actual length), (char #1), (char #2), (char #3), etc.
   49                   ;
   50 E806  7F          INBUFF:  DB     127             ;length of input buffer.
   51 E807  00                   DB     0               ;current length of contents.
   52 E808  43 6F 70 79          DB     "Copyright"
   53 E811  20 31 39 37          DB     " 1979 (c) by Digital Research      "
   54 E834  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   55 E84B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   56 E862  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   57 E879  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   58 E888  E808        INPOINT: DW     INBUFF+2        ;input line pointer
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   2
BDOS22  Z80

   59 E88A  0000        NAMEPNT: DW     0               ;input line pointer used for error message. Points to
   60                   ;                       ;start of name in error.
   61                   ;
   62                   ;   Routine to print (A) on the console. All registers used.
   63                   ;
   64 E88C  5F          PRINT:  LD      E,A             ;setup bdos call.
   65 E88D  0E 02               LD      C,2
   66 E88F  C3 0005             JP      ENTRY
   67                   ;
   68                   ;   Routine to print (A) on the console and to save (BC).
   69                   ;
   70 E892  C5          PRINTB: PUSH    BC
   71 E893  CD E88C             CALL    PRINT
   72 E896  C1                  POP     BC
   73 E897  C9                  RET     
   74                   ;
   75                   ;   Routine to send a carriage return, line feed combination
   76                   ; to the console.
   77                   ;
   78 E898  3E 0D       CRLF:   LD      A,CR
   79 E89A  CD E892             CALL    PRINTB
   80 E89D  3E 0A               LD      A,LF
   81 E89F  C3 E892             JP      PRINTB
   82                   ;
   83                   ;   Routine to send one space to the console and save (BC).
   84                   ;
   85 E8A2  3E 20       SPACE:  LD      A,' '
   86 E8A4  C3 E892             JP      PRINTB
   87                   ;
   88                   ;   Routine to print character string pointed to be (BC) on the
   89                   ; console. It must terminate with a null byte.
   90                   ;
   91 E8A7  C5          PLINE:  PUSH    BC
   92 E8A8  CD E898             CALL    CRLF
   93 E8AB  E1                  POP     HL
   94 E8AC  7E          PLINE2: LD      A,(HL)
   95 E8AD  B7                  OR      A
   96 E8AE  C8                  RET     Z
   97 E8AF  23                  INC     HL
   98 E8B0  E5                  PUSH    HL
   99 E8B1  CD E88C             CALL    PRINT
  100 E8B4  E1                  POP     HL
  101 E8B5  C3 E8AC             JP      PLINE2
  102                   ;
  103                   ;   Routine to reset the disk system.
  104                   ;
  105 E8B8  0E 0D       RESDSK: LD      C,13
  106 E8BA  C3 0005             JP      ENTRY
  107                   ;
  108                   ;   Routine to select disk (A).
  109                   ;
  110 E8BD  5F          DSKSEL: LD      E,A
  111 E8BE  0E 0E               LD      C,14
  112 E8C0  C3 0005             JP      ENTRY
  113                   ;
  114                   ;   Routine to call bdos and save the return code. The zero
  115                   ; flag is set on a return of 0ffh.
  116                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   3
BDOS22  Z80

  117 E8C3  CD 0005     ENTRY1: CALL    ENTRY
  118 E8C6  32 EFEE             LD      (RTNCODE),A     ;save return code.
  119 E8C9  3C                  INC     A               ;set zero if 0ffh returned.
  120 E8CA  C9                  RET     
  121                   ;
  122                   ;   Routine to open a file. (DE) must point to the FCB.
  123                   ;
  124 E8CB  0E 0F       OPEN:   LD      C,15
  125 E8CD  C3 E8C3             JP      ENTRY1
  126                   ;
  127                   ;   Routine to open file at (FCB).
  128                   ;
  129 E8D0  AF          OPENFCB:XOR     A               ;clear the record number byte at fcb+32
  130 E8D1  32 EFED             LD      (FCB+32),A
  131 E8D4  11 EFCD             LD      DE,FCB
  132 E8D7  C3 E8CB             JP      OPEN
  133                   ;
  134                   ;   Routine to close a file. (DE) points to FCB.
  135                   ;
  136 E8DA  0E 10       CLOSE:  LD      C,16
  137 E8DC  C3 E8C3             JP      ENTRY1
  138                   ;
  139                   ;   Routine to search for the first file with ambigueous name
  140                   ; (DE).
  141                   ;
  142 E8DF  0E 11       SRCHFST:LD      C,17
  143 E8E1  C3 E8C3             JP      ENTRY1
  144                   ;
  145                   ;   Search for the next ambigeous file name.
  146                   ;
  147 E8E4  0E 12       SRCHNXT:LD      C,18
  148 E8E6  C3 E8C3             JP      ENTRY1
  149                   ;
  150                   ;   Search for file at (FCB).
  151                   ;
  152 E8E9  11 EFCD     SRCHFCB:LD      DE,FCB
  153 E8EC  C3 E8DF             JP      SRCHFST
  154                   ;
  155                   ;   Routine to delete a file pointed to by (DE).
  156                   ;
  157 E8EF  0E 13       DELETE: LD      C,19
  158 E8F1  C3 0005             JP      ENTRY
  159                   ;
  160                   ;   Routine to call the bdos and set the zero flag if a zero
  161                   ; status is returned.
  162                   ;
  163 E8F4  CD 0005     ENTRY2: CALL    ENTRY
  164 E8F7  B7                  OR      A               ;set zero flag if appropriate.
  165 E8F8  C9                  RET     
  166                   ;
  167                   ;   Routine to read the next record from a sequential file.
  168                   ; (DE) points to the FCB.
  169                   ;
  170 E8F9  0E 14       RDREC:  LD      C,20
  171 E8FB  C3 E8F4             JP      ENTRY2
  172                   ;
  173                   ;   Routine to read file at (FCB).
  174                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   4
BDOS22  Z80

  175 E8FE  11 EFCD     READFCB:LD      DE,FCB
  176 E901  C3 E8F9             JP      RDREC
  177                   ;
  178                   ;   Routine to write the next record of a sequential file.
  179                   ; (DE) points to the FCB.
  180                   ;
  181 E904  0E 15       WRTREC: LD      C,21
  182 E906  C3 E8F4             JP      ENTRY2
  183                   ;
  184                   ;   Routine to create the file pointed to by (DE).
  185                   ;
  186 E909  0E 16       CREATE: LD      C,22
  187 E90B  C3 E8C3             JP      ENTRY1
  188                   ;
  189                   ;   Routine to rename the file pointed to by (DE). Note that
  190                   ; the new name starts at (DE+16).
  191                   ;
  192 E90E  0E 17       RENAM:  LD      C,23
  193 E910  C3 0005             JP      ENTRY
  194                   ;
  195                   ;   Get the current user code.
  196                   ;
  197 E913  1E FF       GETUSR: LD      E,0FFH
  198                   ;
  199                   ;   Routne to get or set the current user code.
  200                   ; If (E) is FF then this is a GET, else it is a SET.
  201                   ;
  202 E915  0E 20       GETSETUC: LD    C,32
  203 E917  C3 0005             JP      ENTRY
  204                   ;
  205                   ;   Routine to set the current drive byte at (TDRIVE).
  206                   ;
  207 E91A  CD E913     SETCDRV:CALL    GETUSR          ;get user number
  208 E91D  87                  ADD     A,A             ;and shift into the upper 4 bits.
  209 E91E  87                  ADD     A,A
  210 E91F  87                  ADD     A,A
  211 E920  87                  ADD     A,A
  212 E921  21 EFEF             LD      HL,CDRIVE       ;now add in the current drive number.
  213 E924  B6                  OR      (HL)
  214 E925  32 0004             LD      (TDRIVE),A      ;and save.
  215 E928  C9                  RET     
  216                   ;
  217                   ;   Move currently active drive down to (TDRIVE).
  218                   ;
  219 E929  3A EFEF     MOVECD: LD      A,(CDRIVE)
  220 E92C  32 0004             LD      (TDRIVE),A
  221 E92F  C9                  RET     
  222                   ;
  223                   ;   Routine to convert (A) into upper case ascii. Only letters
  224                   ; are affected.
  225                   ;
  226 E930  FE 61       UPPER:  CP      'a'             ;check for letters in the range of 'a' to 'z'.
  227 E932  D8                  RET     C
  228 E933  FE 7B               CP      '{'
  229 E935  D0                  RET     NC
  230 E936  E6 5F               AND     5FH             ;convert it if found.
  231 E938  C9                  RET     
  232                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   5
BDOS22  Z80

  233                   ;   Routine to get a line of input. We must check to see if the
  234                   ; user is in (BATCH) mode. If so, then read the input from file
  235                   ; ($$$.SUB). At the end, reset to console input.
  236                   ;
  237 E939  3A EFAB     GETINP: LD      A,(BATCH)       ;if =0, then use console input.
  238 E93C  B7                  OR      A
  239 E93D  CA E996             JP      Z,GETINP1
  240                   ;
  241                   ;   Use the submit file ($$$.sub) which is prepared by a
  242                   ; SUBMIT run. It must be on drive (A) and it will be deleted
  243                   ; if and error occures (like eof).
  244                   ;
  245 E940  3A EFEF             LD      A,(CDRIVE)      ;select drive 0 if need be.
  246 E943  B7                  OR      A
  247 E944  3E 00               LD      A,0             ;always use drive A for submit.
  248 E946  C4 E8BD             CALL    NZ,DSKSEL       ;select it if required.
  249 E949  11 EFAC             LD      DE,BATCHFCB
  250 E94C  CD E8CB             CALL    OPEN            ;look for it.
  251 E94F  CA E996             JP      Z,GETINP1       ;if not there, use normal input.
  252 E952  3A EFBB             LD      A,(BATCHFCB+15) ;get last record number+1.
  253 E955  3D                  DEC     A
  254 E956  32 EFCC             LD      (BATCHFCB+32),A
  255 E959  11 EFAC             LD      DE,BATCHFCB
  256 E95C  CD E8F9             CALL    RDREC           ;read last record.
  257 E95F  C2 E996             JP      NZ,GETINP1      ;quit on end of file.
  258                   ;
  259                   ;   Move this record into input buffer.
  260                   ;
  261 E962  11 E807             LD      DE,INBUFF+1
  262 E965  21 0080             LD      HL,TBUFF        ;data was read into buffer here.
  263 E968  06 80               LD      B,128           ;all 128 characters may be used.
  264 E96A  CD EC42             CALL    HL2DE           ;(HL) to (DE), (B) bytes.
  265 E96D  21 EFBA             LD      HL,BATCHFCB+14
  266 E970  36 00               LD      (HL),0          ;zero out the 's2' byte.
  267 E972  23                  INC     HL              ;and decrement the record count.
  268 E973  35                  DEC     (HL)
  269 E974  11 EFAC             LD      DE,BATCHFCB     ;close the batch file now.
  270 E977  CD E8DA             CALL    CLOSE
  271 E97A  CA E996             JP      Z,GETINP1       ;quit on an error.
  272 E97D  3A EFEF             LD      A,(CDRIVE)      ;re-select previous drive if need be.
  273 E980  B7                  OR      A
  274 E981  C4 E8BD             CALL    NZ,DSKSEL       ;don't do needless selects.
  275                   ;
  276                   ;   Print line just read on console.
  277                   ;
  278 E984  21 E808             LD      HL,INBUFF+2
  279 E987  CD E8AC             CALL    PLINE2
  280 E98A  CD E9C2             CALL    CHKCON          ;check console, quit on a key.
  281 E98D  CA E9A7             JP      Z,GETINP2       ;jump if no key is pressed.
  282                   ;
  283                   ;   Terminate the submit job on any keyboard input. Delete this
  284                   ; file such that it is not re-started and jump to normal keyboard
  285                   ; input section.
  286                   ;
  287 E990  CD E9DD             CALL    DELBATCH        ;delete the batch file.
  288 E993  C3 EB82             JP      CMMND1          ;and restart command input.
  289                   ;
  290                   ;   Get here for normal keyboard input. Delete the submit file
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   6
BDOS22  Z80

  291                   ; incase there was one.
  292                   ;
  293 E996  CD E9DD     GETINP1:CALL    DELBATCH        ;delete file ($$$.sub).
  294 E999  CD E91A             CALL    SETCDRV         ;reset active disk.
  295 E99C  0E 0A               LD      C,10            ;get line from console device.
  296 E99E  11 E806             LD      DE,INBUFF
  297 E9A1  CD 0005             CALL    ENTRY
  298 E9A4  CD E929             CALL    MOVECD          ;reset current drive (again).
  299                   ;
  300                   ;   Convert input line to upper case.
  301                   ;
  302 E9A7  21 E807     GETINP2:LD      HL,INBUFF+1
  303 E9AA  46                  LD      B,(HL)          ;(B)=character counter.
  304 E9AB  23          GETINP3:INC     HL
  305 E9AC  78                  LD      A,B             ;end of the line?
  306 E9AD  B7                  OR      A
  307 E9AE  CA E9BA             JP      Z,GETINP4
  308 E9B1  7E                  LD      A,(HL)          ;convert to upper case.
  309 E9B2  CD E930             CALL    UPPER
  310 E9B5  77                  LD      (HL),A
  311 E9B6  05                  DEC     B               ;adjust character count.
  312 E9B7  C3 E9AB             JP      GETINP3
  313 E9BA  77          GETINP4:LD      (HL),A          ;add trailing null.
  314 E9BB  21 E808             LD      HL,INBUFF+2
  315 E9BE  22 E888             LD      (INPOINT),HL    ;reset input line pointer.
  316 E9C1  C9                  RET     
  317                   ;
  318                   ;   Routine to check the console for a key pressed. The zero
  319                   ; flag is set is none, else the character is returned in (A).
  320                   ;
  321 E9C2  0E 0B       CHKCON: LD      C,11            ;check console.
  322 E9C4  CD 0005             CALL    ENTRY
  323 E9C7  B7                  OR      A
  324 E9C8  C8                  RET     Z               ;return if nothing.
  325 E9C9  0E 01               LD      C,1             ;else get character.
  326 E9CB  CD 0005             CALL    ENTRY
  327 E9CE  B7                  OR      A               ;clear zero flag and return.
  328 E9CF  C9                  RET     
  329                   ;
  330                   ;   Routine to get the currently active drive number.
  331                   ;
  332 E9D0  0E 19       GETDSK: LD      C,25
  333 E9D2  C3 0005             JP      ENTRY
  334                   ;
  335                   ;   Set the stabdard dma address.
  336                   ;
  337 E9D5  11 0080     STDDMA: LD      DE,TBUFF
  338                   ;
  339                   ;   Routine to set the dma address to (DE).
  340                   ;
  341 E9D8  0E 1A       DMASET: LD      C,26
  342 E9DA  C3 0005             JP      ENTRY
  343                   ;
  344                   ;  Delete the batch file created by SUBMIT.
  345                   ;
  346 E9DD  21 EFAB     DELBATCH: LD    HL,BATCH        ;is batch active?
  347 E9E0  7E                  LD      A,(HL)
  348 E9E1  B7                  OR      A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   7
BDOS22  Z80

  349 E9E2  C8                  RET     Z
  350 E9E3  36 00               LD      (HL),0          ;yes, de-activate it.
  351 E9E5  AF                  XOR     A
  352 E9E6  CD E8BD             CALL    DSKSEL          ;select drive 0 for sure.
  353 E9E9  11 EFAC             LD      DE,BATCHFCB     ;and delete this file.
  354 E9EC  CD E8EF             CALL    DELETE
  355 E9EF  3A EFEF             LD      A,(CDRIVE)      ;reset current drive.
  356 E9F2  C3 E8BD             JP      DSKSEL
  357                   ;
  358                   ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
  359                   ; the same or we halt....
  360                   ;
  361 E9F5  11 EB28     VERIFY: LD      DE,PATTRN1      ;these are the serial number bytes.
  362 E9F8  21 F000             LD      HL,PATTRN2      ;ditto, but how could they be different?
  363 E9FB  06 06               LD      B,6             ;6 bytes each.
  364 E9FD  1A          VERIFY1:LD      A,(DE)
  365 E9FE  BE                  CP      (HL)
  366 E9FF  C2 EBCF             JP      NZ,HALT         ;jump to halt routine.
  367 EA02  13                  INC     DE
  368 EA03  23                  INC     HL
  369 EA04  05                  DEC     B
  370 EA05  C2 E9FD             JP      NZ,VERIFY1
  371 EA08  C9                  RET     
  372                   ;
  373                   ;   Print back file name with a '?' to indicate a syntax error.
  374                   ;
  375 EA09  CD E898     SYNERR: CALL    CRLF            ;end current line.
  376 EA0C  2A E88A             LD      HL,(NAMEPNT)    ;this points to name in error.
  377 EA0F  7E          SYNERR1:LD      A,(HL)          ;print it until a space or null is found.
  378 EA10  FE 20               CP      ' '
  379 EA12  CA EA22             JP      Z,SYNERR2
  380 EA15  B7                  OR      A
  381 EA16  CA EA22             JP      Z,SYNERR2
  382 EA19  E5                  PUSH    HL
  383 EA1A  CD E88C             CALL    PRINT
  384 EA1D  E1                  POP     HL
  385 EA1E  23                  INC     HL
  386 EA1F  C3 EA0F             JP      SYNERR1
  387 EA22  3E 3F       SYNERR2:LD      A,'?'           ;add trailing '?'.
  388 EA24  CD E88C             CALL    PRINT
  389 EA27  CD E898             CALL    CRLF
  390 EA2A  CD E9DD             CALL    DELBATCH        ;delete any batch file.
  391 EA2D  C3 EB82             JP      CMMND1          ;and restart from console input.
  392                   ;
  393                   ;   Check character at (DE) for legal command input. Note that the
  394                   ; zero flag is set if the character is a delimiter.
  395                   ;
  396 EA30  1A          CHECK:  LD      A,(DE)
  397 EA31  B7                  OR      A
  398 EA32  C8                  RET     Z
  399 EA33  FE 20               CP      ' '             ;control characters are not legal here.
  400 EA35  DA EA09             JP      C,SYNERR
  401 EA38  C8                  RET     Z               ;check for valid delimiter.
  402 EA39  FE 3D               CP      '='
  403 EA3B  C8                  RET     Z
  404 EA3C  FE 5F               CP      '_'
  405 EA3E  C8                  RET     Z
  406 EA3F  FE 2E               CP      '.'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   8
BDOS22  Z80

  407 EA41  C8                  RET     Z
  408 EA42  FE 3A               CP      ':'
  409 EA44  C8                  RET     Z
  410 EA45  FE 3B               CP      03BH ; ';'
  411 EA47  C8                  RET     Z
  412 EA48  FE 3C               CP      '<'
  413 EA4A  C8                  RET     Z
  414 EA4B  FE 3E               CP      '>'
  415 EA4D  C8                  RET     Z
  416 EA4E  C9                  RET     
  417                   ;
  418                   ;   Get the next non-blank character from (DE).
  419                   ;
  420 EA4F  1A          NONBLANK: LD    A,(DE)
  421 EA50  B7                  OR      A               ;string ends with a null.
  422 EA51  C8                  RET     Z
  423 EA52  FE 20               CP      ' '
  424 EA54  C0                  RET     NZ
  425 EA55  13                  INC     DE
  426 EA56  C3 EA4F             JP      NONBLANK
  427                   ;
  428                   ;   Add (HL)=(HL)+(A)
  429                   ;
  430 EA59  85          ADDHL:  ADD     A,L
  431 EA5A  6F                  LD      L,A
  432 EA5B  D0                  RET     NC              ;take care of any carry.
  433 EA5C  24                  INC     H
  434 EA5D  C9                  RET     
  435                   ;
  436                   ;   Convert the first name in (FCB).
  437                   ;
  438 EA5E  3E 00       CONVFST:LD      A,0
  439                   ;
  440                   ;   Format a file name (convert * to '?', etc.). On return,
  441                   ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
  442                   ; the position within the fcb for the name (either 0 or 16).
  443                   ;
  444 EA60  21 EFCD     CONVERT:LD      HL,FCB
  445 EA63  CD EA59             CALL    ADDHL
  446 EA66  E5                  PUSH    HL
  447 EA67  E5                  PUSH    HL
  448 EA68  AF                  XOR     A
  449 EA69  32 EFF0             LD      (CHGDRV),A      ;initialize drive change flag.
  450 EA6C  2A E888             LD      HL,(INPOINT)    ;set (HL) as pointer into input line.
  451 EA6F  EB                  EX      DE,HL
  452 EA70  CD EA4F             CALL    NONBLANK        ;get next non-blank character.
  453 EA73  EB                  EX      DE,HL
  454 EA74  22 E88A             LD      (NAMEPNT),HL    ;save pointer here for any error message.
  455 EA77  EB                  EX      DE,HL
  456 EA78  E1                  POP     HL
  457 EA79  1A                  LD      A,(DE)          ;get first character.
  458 EA7A  B7                  OR      A
  459 EA7B  CA EA89             JP      Z,CONVRT1
  460 EA7E  DE 40               SBC     A,'A'-1         ;might be a drive name, convert to binary.
  461 EA80  47                  LD      B,A             ;and save.
  462 EA81  13                  INC     DE              ;check next character for a ':'.
  463 EA82  1A                  LD      A,(DE)
  464 EA83  FE 3A               CP      ':'
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page   9
BDOS22  Z80

  465 EA85  CA EA90             JP      Z,CONVRT2
  466 EA88  1B                  DEC     DE              ;nope, move pointer back to the start of the line.
  467 EA89  3A EFEF     CONVRT1:LD      A,(CDRIVE)
  468 EA8C  77                  LD      (HL),A
  469 EA8D  C3 EA96             JP      CONVRT3
  470 EA90  78          CONVRT2:LD      A,B
  471 EA91  32 EFF0             LD      (CHGDRV),A      ;set change in drives flag.
  472 EA94  70                  LD      (HL),B
  473 EA95  13                  INC     DE
  474                   ;
  475                   ;   Convert the basic file name.
  476                   ;
  477 EA96  06 08       CONVRT3:LD      B,08H
  478 EA98  CD EA30     CONVRT4:CALL    CHECK
  479 EA9B  CA EAB9             JP      Z,CONVRT8
  480 EA9E  23                  INC     HL
  481 EA9F  FE 2A               CP      '*'             ;note that an '*' will fill the remaining
  482 EAA1  C2 EAA9             JP      NZ,CONVRT5      ;field with '?'.
  483 EAA4  36 3F               LD      (HL),'?'
  484 EAA6  C3 EAAB             JP      CONVRT6
  485 EAA9  77          CONVRT5:LD      (HL),A
  486 EAAA  13                  INC     DE
  487 EAAB  05          CONVRT6:DEC     B
  488 EAAC  C2 EA98             JP      NZ,CONVRT4
  489 EAAF  CD EA30     CONVRT7:CALL    CHECK           ;get next delimiter.
  490 EAB2  CA EAC0             JP      Z,GETEXT
  491 EAB5  13                  INC     DE
  492 EAB6  C3 EAAF             JP      CONVRT7
  493 EAB9  23          CONVRT8:INC     HL              ;blank fill the file name.
  494 EABA  36 20               LD      (HL),' '
  495 EABC  05                  DEC     B
  496 EABD  C2 EAB9             JP      NZ,CONVRT8
  497                   ;
  498                   ;   Get the extension and convert it.
  499                   ;
  500 EAC0  06 03       GETEXT: LD      B,03H
  501 EAC2  FE 2E               CP      '.'
  502 EAC4  C2 EAE9             JP      NZ,GETEXT5
  503 EAC7  13                  INC     DE
  504 EAC8  CD EA30     GETEXT1:CALL    CHECK
  505 EACB  CA EAE9             JP      Z,GETEXT5
  506 EACE  23                  INC     HL
  507 EACF  FE 2A               CP      '*'
  508 EAD1  C2 EAD9             JP      NZ,GETEXT2
  509 EAD4  36 3F               LD      (HL),'?'
  510 EAD6  C3 EADB             JP      GETEXT3
  511 EAD9  77          GETEXT2:LD      (HL),A
  512 EADA  13                  INC     DE
  513 EADB  05          GETEXT3:DEC     B
  514 EADC  C2 EAC8             JP      NZ,GETEXT1
  515 EADF  CD EA30     GETEXT4:CALL    CHECK
  516 EAE2  CA EAF0             JP      Z,GETEXT6
  517 EAE5  13                  INC     DE
  518 EAE6  C3 EADF             JP      GETEXT4
  519 EAE9  23          GETEXT5:INC     HL
  520 EAEA  36 20               LD      (HL),' '
  521 EAEC  05                  DEC     B
  522 EAED  C2 EAE9             JP      NZ,GETEXT5
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  10
BDOS22  Z80

  523 EAF0  06 03       GETEXT6:LD      B,3
  524 EAF2  23          GETEXT7:INC     HL
  525 EAF3  36 00               LD      (HL),0
  526 EAF5  05                  DEC     B
  527 EAF6  C2 EAF2             JP      NZ,GETEXT7
  528 EAF9  EB                  EX      DE,HL
  529 EAFA  22 E888             LD      (INPOINT),HL    ;save input line pointer.
  530 EAFD  E1                  POP     HL
  531                   ;
  532                   ;   Check to see if this is an ambigeous file name specification.
  533                   ; Set the (A) register to non zero if it is.
  534                   ;
  535 EAFE  01 000B             LD      BC,11           ;set name length.
  536 EB01  23          GETEXT8:INC     HL
  537 EB02  7E                  LD      A,(HL)
  538 EB03  FE 3F               CP      '?'             ;any question marks?
  539 EB05  C2 EB09             JP      NZ,GETEXT9
  540 EB08  04                  INC     B               ;count them.
  541 EB09  0D          GETEXT9:DEC     C
  542 EB0A  C2 EB01             JP      NZ,GETEXT8
  543 EB0D  78                  LD      A,B
  544 EB0E  B7                  OR      A
  545 EB0F  C9                  RET     
  546                   ;
  547                   ;   CP/M command table. Note commands can be either 3 or 4 characters long.
  548                   ;
  549         0006      NUMCMDS  EQU    6               ;number of commands
  550 EB10  44 49 52 20 CMDTBL:  DB     "DIR "
  551 EB14  45 52 41 20          DB     "ERA "
  552 EB18  54 59 50 45          DB     "TYPE"
  553 EB1C  53 41 56 45          DB     "SAVE"
  554 EB20  52 45 4E 20          DB     "REN "
  555 EB24  55 53 45 52          DB     "USER"
  556                   ;
  557                   ;   The following six bytes must agree with those at (PATTRN2)
  558                   ; or cp/m will HALT. Why?
  559                   ;
  560 EB28  00 16 00 00 PATTRN1: DB     0,22,0,0,0,0    ;(* serial number bytes *).
  561                   ;
  562                   ;   Search the command table for a match with what has just
  563                   ; been entered. If a match is found, then we jump to the
  564                   ; proper section. Else jump to (UNKNOWN).
  565                   ; On return, the (C) register is set to the command number
  566                   ; that matched (or NUMCMDS+1 if no match).
  567                   ;
  568 EB2E  21 EB10     SEARCH: LD      HL,CMDTBL
  569 EB31  0E 00               LD      C,0
  570 EB33  79          SEARCH1:LD      A,C
  571 EB34  FE 06               CP      NUMCMDS         ;this commands exists.
  572 EB36  D0                  RET     NC
  573 EB37  11 EFCE             LD      DE,FCB+1        ;check this one.
  574 EB3A  06 04               LD      B,4             ;max command length.
  575 EB3C  1A          SEARCH2:LD      A,(DE)
  576 EB3D  BE                  CP      (HL)
  577 EB3E  C2 EB4F             JP      NZ,SEARCH3      ;not a match.
  578 EB41  13                  INC     DE
  579 EB42  23                  INC     HL
  580 EB43  05                  DEC     B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  11
BDOS22  Z80

  581 EB44  C2 EB3C             JP      NZ,SEARCH2
  582 EB47  1A                  LD      A,(DE)          ;allow a 3 character command to match.
  583 EB48  FE 20               CP      ' '
  584 EB4A  C2 EB54             JP      NZ,SEARCH4
  585 EB4D  79                  LD      A,C             ;set return register for this command.
  586 EB4E  C9                  RET     
  587 EB4F  23          SEARCH3:INC     HL
  588 EB50  05                  DEC     B
  589 EB51  C2 EB4F             JP      NZ,SEARCH3
  590 EB54  0C          SEARCH4:INC     C
  591 EB55  C3 EB33             JP      SEARCH1
  592                   ;
  593                   ;   Set the input buffer to empty and then start the command
  594                   ; processor (ccp).
  595                   ;
  596 EB58  AF          CLEARBUF: XOR   A
  597 EB59  32 E807             LD      (INBUFF+1),A    ;second byte is actual length.
  598                   ;
  599                   ;**************************************************************
  600                   ;*
  601                   ;*
  602                   ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
  603                   ;*
  604                   ;**************************************************************
  605                   ;*
  606 EB5C  31 EFAB     COMMAND:LD      SP,CCPSTACK     ;setup stack area.
  607 EB5F  C5                  PUSH    BC              ;note that (C) should be equal to:
  608 EB60  79                  LD      A,C             ;(uuuudddd) where 'uuuu' is the user number
  609 EB61  1F                  RRA                     ;and 'dddd' is the drive number.
  610 EB62  1F                  RRA     
  611 EB63  1F                  RRA     
  612 EB64  1F                  RRA     
  613 EB65  E6 0F               AND     0FH             ;isolate the user number.
  614 EB67  5F                  LD      E,A
  615 EB68  CD E915             CALL    GETSETUC        ;and set it.
  616 EB6B  CD E8B8             CALL    RESDSK          ;reset the disk system.
  617 EB6E  32 EFAB             LD      (BATCH),A       ;clear batch mode flag.
  618 EB71  C1                  POP     BC
  619 EB72  79                  LD      A,C
  620 EB73  E6 0F               AND     0FH             ;isolate the drive number.
  621 EB75  32 EFEF             LD      (CDRIVE),A      ;and save.
  622 EB78  CD E8BD             CALL    DSKSEL          ;...and select.
  623 EB7B  3A E807             LD      A,(INBUFF+1)
  624 EB7E  B7                  OR      A               ;anything in input buffer already?
  625 EB7F  C2 EB98             JP      NZ,CMMND2       ;yes, we just process it.
  626                   ;
  627                   ;   Entry point to get a command line from the console.
  628                   ;
  629 EB82  31 EFAB     CMMND1: LD      SP,CCPSTACK     ;set stack straight.
  630 EB85  CD E898             CALL    CRLF            ;start a new line on the screen.
  631 EB88  CD E9D0             CALL    GETDSK          ;get current drive.
  632 EB8B  C6 41               ADD     A,'A'
  633 EB8D  CD E88C             CALL    PRINT           ;print current drive.
  634 EB90  3E 3E               LD      A,'>'
  635 EB92  CD E88C             CALL    PRINT           ;and add prompt.
  636 EB95  CD E939             CALL    GETINP          ;get line from user.
  637                   ;
  638                   ;   Process command line here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  12
BDOS22  Z80

  639                   ;
  640 EB98  11 0080     CMMND2: LD      DE,TBUFF
  641 EB9B  CD E9D8             CALL    DMASET          ;set standard dma address.
  642 EB9E  CD E9D0             CALL    GETDSK
  643 EBA1  32 EFEF             LD      (CDRIVE),A      ;set current drive.
  644 EBA4  CD EA5E             CALL    CONVFST         ;convert name typed in.
  645 EBA7  C4 EA09             CALL    NZ,SYNERR       ;wild cards are not allowed.
  646 EBAA  3A EFF0             LD      A,(CHGDRV)      ;if a change in drives was indicated,
  647 EBAD  B7                  OR      A               ;then treat this as an unknown command
  648 EBAE  C2 EEA5             JP      NZ,UNKNOWN      ;which gets executed.
  649 EBB1  CD EB2E             CALL    SEARCH          ;else search command table for a match.
  650                   ;
  651                   ;   Note that an unknown command returns
  652                   ; with (A) pointing to the last address
  653                   ; in our table which is (UNKNOWN).
  654                   ;
  655 EBB4  21 EBC1             LD      HL,CMDADR       ;now, look thru our address table for command (A).
  656 EBB7  5F                  LD      E,A             ;set (DE) to command number.
  657 EBB8  16 00               LD      D,0
  658 EBBA  19                  ADD     HL,DE
  659 EBBB  19                  ADD     HL,DE           ;(HL)=(CMDADR)+2*(command number).
  660 EBBC  7E                  LD      A,(HL)          ;now pick out this address.
  661 EBBD  23                  INC     HL
  662 EBBE  66                  LD      H,(HL)
  663 EBBF  6F                  LD      L,A
  664 EBC0  E9                  JP      (HL)            ;now execute it.
  665                   ;
  666                   ;   CP/M command address table.
  667                   ;
  668 EBC1  EC77  ED1F  CMDADR:  DW     DIRECT,ERASE,TYPE,SAVE
  669 EBC9  EE10  EE8E           DW     RENAME,USER,UNKNOWN
  670                   ;
  671                   ;   Halt the system. Reason for this is unknown at present.
  672                   ;
  673 EBCF  21 76F3     HALT:   LD      HL,76F3H        ;'DI HLT' instructions.
  674 EBD2  22 E800             LD      (CBASE),HL
  675 EBD5  21 E800             LD      HL,CBASE
  676 EBD8  E9                  JP      (HL)
  677                   ;
  678                   ;   Read error while TYPEing a file.
  679                   ;
  680 EBD9  01 EBDF     RDERROR:LD      BC,RDERR
  681 EBDC  C3 E8A7             JP      PLINE
  682 EBDF  52 65 61 64 RDERR:   DB     "Read error"
  683 EBE9  00                   DB     0
  684                   ;
  685                   ;   Required file was not located.
  686                   ;
  687 EBEA  01 EBF0     NONE:   LD      BC,NOFILE
  688 EBED  C3 E8A7             JP      PLINE
  689 EBF0  4E 6F 20 66 NOFILE:  DB     "No file"
  690 EBF7  00                   DB     0
  691                   ;
  692                   ;   Decode a command of the form 'A>filename number{ filename}.
  693                   ; Note that a drive specifier is not allowed on the first file
  694                   ; name. On return, the number is in register (A). Any error
  695                   ; causes 'filename?' to be printed and the command is aborted.
  696                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  13
BDOS22  Z80

  697 EBF8  CD EA5E     DECODE: CALL    CONVFST         ;convert filename.
  698 EBFB  3A EFF0             LD      A,(CHGDRV)      ;do not allow a drive to be specified.
  699 EBFE  B7                  OR      A
  700 EBFF  C2 EA09             JP      NZ,SYNERR
  701 EC02  21 EFCE             LD      HL,FCB+1        ;convert number now.
  702 EC05  01 000B             LD      BC,11           ;(B)=sum register, (C)=max digit count.
  703 EC08  7E          DECODE1:LD      A,(HL)
  704 EC09  FE 20               CP      ' '             ;a space terminates the numeral.
  705 EC0B  CA EC33             JP      Z,DECODE3
  706 EC0E  23                  INC     HL
  707 EC0F  D6 30               SUB     '0'             ;make binary from ascii.
  708 EC11  FE 0A               CP      10              ;legal digit?
  709 EC13  D2 EA09             JP      NC,SYNERR
  710 EC16  57                  LD      D,A             ;yes, save it in (D).
  711 EC17  78                  LD      A,B             ;compute (B)=(B)*10 and check for overflow.
  712 EC18  E6 E0               AND     0E0H
  713 EC1A  C2 EA09             JP      NZ,SYNERR
  714 EC1D  78                  LD      A,B
  715 EC1E  07                  RLCA    
  716 EC1F  07                  RLCA    
  717 EC20  07                  RLCA                    ;(A)=(B)*8
  718 EC21  80                  ADD     A,B             ;.......*9
  719 EC22  DA EA09             JP      C,SYNERR
  720 EC25  80                  ADD     A,B             ;.......*10
  721 EC26  DA EA09             JP      C,SYNERR
  722 EC29  82                  ADD     A,D             ;add in new digit now.
  723 EC2A  DA EA09     DECODE2:JP      C,SYNERR
  724 EC2D  47                  LD      B,A             ;and save result.
  725 EC2E  0D                  DEC     C               ;only look at 11 digits.
  726 EC2F  C2 EC08             JP      NZ,DECODE1
  727 EC32  C9                  RET     
  728 EC33  7E          DECODE3:LD      A,(HL)          ;spaces must follow (why?).
  729 EC34  FE 20               CP      ' '
  730 EC36  C2 EA09             JP      NZ,SYNERR
  731 EC39  23                  INC     HL
  732 EC3A  0D          DECODE4:DEC     C
  733 EC3B  C2 EC33             JP      NZ,DECODE3
  734 EC3E  78                  LD      A,B             ;set (A)=the numeric value entered.
  735 EC3F  C9                  RET     
  736                   ;
  737                   ;   Move 3 bytes from (HL) to (DE). Note that there is only
  738                   ; one reference to this at (A2D5h).
  739                   ;
  740 EC40  06 03       MOVE3:  LD      B,3
  741                   ;
  742                   ;   Move (B) bytes from (HL) to (DE).
  743                   ;
  744 EC42  7E          HL2DE:  LD      A,(HL)
  745 EC43  12                  LD      (DE),A
  746 EC44  23                  INC     HL
  747 EC45  13                  INC     DE
  748 EC46  05                  DEC     B
  749 EC47  C2 EC42             JP      NZ,HL2DE
  750 EC4A  C9                  RET     
  751                   ;
  752                   ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
  753                   ;
  754 EC4B  21 0080     EXTRACT:LD      HL,TBUFF
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  14
BDOS22  Z80

  755 EC4E  81                  ADD     A,C
  756 EC4F  CD EA59             CALL    ADDHL
  757 EC52  7E                  LD      A,(HL)
  758 EC53  C9                  RET     
  759                   ;
  760                   ;  Check drive specified. If it means a change, then the new
  761                   ; drive will be selected. In any case, the drive byte of the
  762                   ; fcb will be set to null (means use current drive).
  763                   ;
  764 EC54  AF          DSELECT:XOR     A               ;null out first byte of fcb.
  765 EC55  32 EFCD             LD      (FCB),A
  766 EC58  3A EFF0             LD      A,(CHGDRV)      ;a drive change indicated?
  767 EC5B  B7                  OR      A
  768 EC5C  C8                  RET     Z
  769 EC5D  3D                  DEC     A               ;yes, is it the same as the current drive?
  770 EC5E  21 EFEF             LD      HL,CDRIVE
  771 EC61  BE                  CP      (HL)
  772 EC62  C8                  RET     Z
  773 EC63  C3 E8BD             JP      DSKSEL          ;no. Select it then.
  774                   ;
  775                   ;   Check the drive selection and reset it to the previous
  776                   ; drive if it was changed for the preceeding command.
  777                   ;
  778 EC66  3A EFF0     RESETDR:LD      A,(CHGDRV)      ;drive change indicated?
  779 EC69  B7                  OR      A
  780 EC6A  C8                  RET     Z
  781 EC6B  3D                  DEC     A               ;yes, was it a different drive?
  782 EC6C  21 EFEF             LD      HL,CDRIVE
  783 EC6F  BE                  CP      (HL)
  784 EC70  C8                  RET     Z
  785 EC71  3A EFEF             LD      A,(CDRIVE)      ;yes, re-select our old drive.
  786 EC74  C3 E8BD             JP      DSKSEL
  787                   ;
  788                   ;**************************************************************
  789                   ;*
  790                   ;*           D I R E C T O R Y   C O M M A N D
  791                   ;*
  792                   ;**************************************************************
  793                   ;
  794 EC77  CD EA5E     DIRECT: CALL    CONVFST         ;convert file name.
  795 EC7A  CD EC54             CALL    DSELECT         ;select indicated drive.
  796 EC7D  21 EFCE             LD      HL,FCB+1        ;was any file indicated?
  797 EC80  7E                  LD      A,(HL)
  798 EC81  FE 20               CP      ' '
  799 EC83  C2 EC8F             JP      NZ,DIRECT2
  800 EC86  06 0B               LD      B,11            ;no. Fill field with '?' - same as *.*.
  801 EC88  36 3F       DIRECT1:LD      (HL),'?'
  802 EC8A  23                  INC     HL
  803 EC8B  05                  DEC     B
  804 EC8C  C2 EC88             JP      NZ,DIRECT1
  805 EC8F  1E 00       DIRECT2:LD      E,0             ;set initial cursor position.
  806 EC91  D5                  PUSH    DE
  807 EC92  CD E8E9             CALL    SRCHFCB         ;get first file name.
  808 EC95  CC EBEA             CALL    Z,NONE          ;none found at all?
  809 EC98  CA ED1B     DIRECT3:JP      Z,DIRECT9       ;terminate if no more names.
  810 EC9B  3A EFEE             LD      A,(RTNCODE)     ;get file's position in segment (0-3).
  811 EC9E  0F                  RRCA    
  812 EC9F  0F                  RRCA    
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  15
BDOS22  Z80

  813 ECA0  0F                  RRCA    
  814 ECA1  E6 60               AND     60H             ;(A)=position*32
  815 ECA3  4F                  LD      C,A
  816 ECA4  3E 0A               LD      A,10
  817 ECA6  CD EC4B             CALL    EXTRACT         ;extract the tenth entry in fcb.
  818 ECA9  17                  RLA                     ;check system file status bit.
  819 ECAA  DA ED0F             JP      C,DIRECT8       ;we don't list them.
  820 ECAD  D1                  POP     DE
  821 ECAE  7B                  LD      A,E             ;bump name count.
  822 ECAF  1C                  INC     E
  823 ECB0  D5                  PUSH    DE
  824 ECB1  E6 03               AND     03H             ;at end of line?
  825 ECB3  F5                  PUSH    AF
  826 ECB4  C2 ECCC             JP      NZ,DIRECT4
  827 ECB7  CD E898             CALL    CRLF            ;yes, end this line and start another.
  828 ECBA  C5                  PUSH    BC
  829 ECBB  CD E9D0             CALL    GETDSK          ;start line with ('A:').
  830 ECBE  C1                  POP     BC
  831 ECBF  C6 41               ADD     A,'A'
  832 ECC1  CD E892             CALL    PRINTB
  833 ECC4  3E 3A               LD      A,':'
  834 ECC6  CD E892             CALL    PRINTB
  835 ECC9  C3 ECD4             JP      DIRECT5
  836 ECCC  CD E8A2     DIRECT4:CALL    SPACE           ;add seperator between file names.
  837 ECCF  3E 3A               LD      A,':'
  838 ECD1  CD E892             CALL    PRINTB
  839 ECD4  CD E8A2     DIRECT5:CALL    SPACE
  840 ECD7  06 01               LD      B,1             ;'extract' each file name character at a time.
  841 ECD9  78          DIRECT6:LD      A,B
  842 ECDA  CD EC4B             CALL    EXTRACT
  843 ECDD  E6 7F               AND     7FH             ;strip bit 7 (status bit).
  844 ECDF  FE 20               CP      ' '             ;are we at the end of the name?
  845 ECE1  C2 ECF9             JP      NZ,DRECT65
  846 ECE4  F1                  POP     AF              ;yes, don't print spaces at the end of a line.
  847 ECE5  F5                  PUSH    AF
  848 ECE6  FE 03               CP      3
  849 ECE8  C2 ECF7             JP      NZ,DRECT63
  850 ECEB  3E 09               LD      A,9             ;first check for no extension.
  851 ECED  CD EC4B             CALL    EXTRACT
  852 ECF0  E6 7F               AND     7FH
  853 ECF2  FE 20               CP      ' '
  854 ECF4  CA ED0E             JP      Z,DIRECT7       ;don't print spaces.
  855 ECF7  3E 20       DRECT63:LD      A,' '           ;else print them.
  856 ECF9  CD E892     DRECT65:CALL    PRINTB
  857 ECFC  04                  INC     B               ;bump to next character psoition.
  858 ECFD  78                  LD      A,B
  859 ECFE  FE 0C               CP      12              ;end of the name?
  860 ED00  D2 ED0E             JP      NC,DIRECT7
  861 ED03  FE 09               CP      9               ;nope, starting extension?
  862 ED05  C2 ECD9             JP      NZ,DIRECT6
  863 ED08  CD E8A2             CALL    SPACE           ;yes, add seperating space.
  864 ED0B  C3 ECD9             JP      DIRECT6
  865 ED0E  F1          DIRECT7:POP     AF              ;get the next file name.
  866 ED0F  CD E9C2     DIRECT8:CALL    CHKCON          ;first check console, quit on anything.
  867 ED12  C2 ED1B             JP      NZ,DIRECT9
  868 ED15  CD E8E4             CALL    SRCHNXT         ;get next name.
  869 ED18  C3 EC98             JP      DIRECT3         ;and continue with our list.
  870 ED1B  D1          DIRECT9:POP     DE              ;restore the stack and return to command level.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  16
BDOS22  Z80

  871 ED1C  C3 EF86             JP      GETBACK
  872                   ;
  873                   ;**************************************************************
  874                   ;*
  875                   ;*                E R A S E   C O M M A N D
  876                   ;*
  877                   ;**************************************************************
  878                   ;
  879 ED1F  CD EA5E     ERASE:  CALL    CONVFST         ;convert file name.
  880 ED22  FE 0B               CP      11              ;was '*.*' entered?
  881 ED24  C2 ED42             JP      NZ,ERASE1
  882 ED27  01 ED52             LD      BC,YESNO        ;yes, ask for confirmation.
  883 ED2A  CD E8A7             CALL    PLINE
  884 ED2D  CD E939             CALL    GETINP
  885 ED30  21 E807             LD      HL,INBUFF+1
  886 ED33  35                  DEC     (HL)            ;must be exactly 'y'.
  887 ED34  C2 EB82             JP      NZ,CMMND1
  888 ED37  23                  INC     HL
  889 ED38  7E                  LD      A,(HL)
  890 ED39  FE 59               CP      'Y'
  891 ED3B  C2 EB82             JP      NZ,CMMND1
  892 ED3E  23                  INC     HL
  893 ED3F  22 E888             LD      (INPOINT),HL    ;save input line pointer.
  894 ED42  CD EC54     ERASE1: CALL    DSELECT         ;select desired disk.
  895 ED45  11 EFCD             LD      DE,FCB
  896 ED48  CD E8EF             CALL    DELETE          ;delete the file.
  897 ED4B  3C                  INC     A
  898 ED4C  CC EBEA             CALL    Z,NONE          ;not there?
  899 ED4F  C3 EF86             JP      GETBACK         ;return to command level now.
  900 ED52  41 6C 6C 20 YESNO:   DB     "All (y/n)?"
  901 ED5C  00                   DB     0
  902                   ;
  903                   ;**************************************************************
  904                   ;*
  905                   ;*            T Y P E   C O M M A N D
  906                   ;*
  907                   ;**************************************************************
  908                   ;
  909 ED5D  CD EA5E     TYPE:   CALL    CONVFST         ;convert file name.
  910 ED60  C2 EA09             JP      NZ,SYNERR       ;wild cards not allowed.
  911 ED63  CD EC54             CALL    DSELECT         ;select indicated drive.
  912 ED66  CD E8D0             CALL    OPENFCB         ;open the file.
  913 ED69  CA EDA7             JP      Z,TYPE5         ;not there?
  914 ED6C  CD E898             CALL    CRLF            ;ok, start a new line on the screen.
  915 ED6F  21 EFF1             LD      HL,NBYTES       ;initialize byte counter.
  916 ED72  36 FF               LD      (HL),0FFH       ;set to read first sector.
  917 ED74  21 EFF1     TYPE1:  LD      HL,NBYTES
  918 ED77  7E          TYPE2:  LD      A,(HL)          ;have we written the entire sector?
  919 ED78  FE 80               CP      128
  920 ED7A  DA ED87             JP      C,TYPE3
  921 ED7D  E5                  PUSH    HL              ;yes, read in the next one.
  922 ED7E  CD E8FE             CALL    READFCB
  923 ED81  E1                  POP     HL
  924 ED82  C2 EDA0             JP      NZ,TYPE4        ;end or error?
  925 ED85  AF                  XOR     A               ;ok, clear byte counter.
  926 ED86  77                  LD      (HL),A
  927 ED87  34          TYPE3:  INC     (HL)            ;count this byte.
  928 ED88  21 0080             LD      HL,TBUFF        ;and get the (A)th one from the buffer (TBUFF).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  17
BDOS22  Z80

  929 ED8B  CD EA59             CALL    ADDHL
  930 ED8E  7E                  LD      A,(HL)
  931 ED8F  FE 1A               CP      CNTRLZ          ;end of file mark?
  932 ED91  CA EF86             JP      Z,GETBACK
  933 ED94  CD E88C             CALL    PRINT           ;no, print it.
  934 ED97  CD E9C2             CALL    CHKCON          ;check console, quit if anything ready.
  935 ED9A  C2 EF86             JP      NZ,GETBACK
  936 ED9D  C3 ED74             JP      TYPE1
  937                   ;
  938                   ;   Get here on an end of file or read error.
  939                   ;
  940 EDA0  3D          TYPE4:  DEC     A               ;read error?
  941 EDA1  CA EF86             JP      Z,GETBACK
  942 EDA4  CD EBD9             CALL    RDERROR         ;yes, print message.
  943 EDA7  CD EC66     TYPE5:  CALL    RESETDR         ;and reset proper drive
  944 EDAA  C3 EA09             JP      SYNERR          ;now print file name with problem.
  945                   ;
  946                   ;**************************************************************
  947                   ;*
  948                   ;*            S A V E   C O M M A N D
  949                   ;*
  950                   ;**************************************************************
  951                   ;
  952 EDAD  CD EBF8     SAVE:   CALL    DECODE          ;get numeric number that follows SAVE.
  953 EDB0  F5                  PUSH    AF              ;save number of pages to write.
  954 EDB1  CD EA5E             CALL    CONVFST         ;convert file name.
  955 EDB4  C2 EA09             JP      NZ,SYNERR       ;wild cards not allowed.
  956 EDB7  CD EC54             CALL    DSELECT         ;select specified drive.
  957 EDBA  11 EFCD             LD      DE,FCB          ;now delete this file.
  958 EDBD  D5                  PUSH    DE
  959 EDBE  CD E8EF             CALL    DELETE
  960 EDC1  D1                  POP     DE
  961 EDC2  CD E909             CALL    CREATE          ;and create it again.
  962 EDC5  CA EDFB             JP      Z,SAVE3         ;can't create?
  963 EDC8  AF                  XOR     A               ;clear record number byte.
  964 EDC9  32 EFED             LD      (FCB+32),A
  965 EDCC  F1                  POP     AF              ;convert pages to sectors.
  966 EDCD  6F                  LD      L,A
  967 EDCE  26 00               LD      H,0
  968 EDD0  29                  ADD     HL,HL           ;(HL)=number of sectors to write.
  969 EDD1  11 0100             LD      DE,TBASE        ;and we start from here.
  970 EDD4  7C          SAVE1:  LD      A,H             ;done yet?
  971 EDD5  B5                  OR      L
  972 EDD6  CA EDF1             JP      Z,SAVE2
  973 EDD9  2B                  DEC     HL              ;nope, count this and compute the start
  974 EDDA  E5                  PUSH    HL              ;of the next 128 byte sector.
  975 EDDB  21 0080             LD      HL,128
  976 EDDE  19                  ADD     HL,DE
  977 EDDF  E5                  PUSH    HL              ;save it and set the transfer address.
  978 EDE0  CD E9D8             CALL    DMASET
  979 EDE3  11 EFCD             LD      DE,FCB          ;write out this sector now.
  980 EDE6  CD E904             CALL    WRTREC
  981 EDE9  D1                  POP     DE              ;reset (DE) to the start of the last sector.
  982 EDEA  E1                  POP     HL              ;restore sector count.
  983 EDEB  C2 EDFB             JP      NZ,SAVE3        ;write error?
  984 EDEE  C3 EDD4             JP      SAVE1
  985                   ;
  986                   ;   Get here after writing all of the file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  18
BDOS22  Z80

  987                   ;
  988 EDF1  11 EFCD     SAVE2:  LD      DE,FCB          ;now close the file.
  989 EDF4  CD E8DA             CALL    CLOSE
  990 EDF7  3C                  INC     A               ;did it close ok?
  991 EDF8  C2 EE01             JP      NZ,SAVE4
  992                   ;
  993                   ;   Print out error message (no space).
  994                   ;
  995 EDFB  01 EE07     SAVE3:  LD      BC,NOSPACE
  996 EDFE  CD E8A7             CALL    PLINE
  997 EE01  CD E9D5     SAVE4:  CALL    STDDMA          ;reset the standard dma address.
  998 EE04  C3 EF86             JP      GETBACK
  999 EE07  4E 6F 20 73 NOSPACE: DB     "No space"
 1000 EE0F  00                   DB     0
 1001                   ;
 1002                   ;**************************************************************
 1003                   ;*
 1004                   ;*           R E N A M E   C O M M A N D
 1005                   ;*
 1006                   ;**************************************************************
 1007                   ;
 1008 EE10  CD EA5E     RENAME: CALL    CONVFST         ;convert first file name.
 1009 EE13  C2 EA09             JP      NZ,SYNERR       ;wild cards not allowed.
 1010 EE16  3A EFF0             LD      A,(CHGDRV)      ;remember any change in drives specified.
 1011 EE19  F5                  PUSH    AF
 1012 EE1A  CD EC54             CALL    DSELECT         ;and select this drive.
 1013 EE1D  CD E8E9             CALL    SRCHFCB         ;is this file present?
 1014 EE20  C2 EE79             JP      NZ,RENAME6      ;yes, print error message.
 1015 EE23  21 EFCD             LD      HL,FCB          ;yes, move this name into second slot.
 1016 EE26  11 EFDD             LD      DE,FCB+16
 1017 EE29  06 10               LD      B,16
 1018 EE2B  CD EC42             CALL    HL2DE
 1019 EE2E  2A E888             LD      HL,(INPOINT)    ;get input pointer.
 1020 EE31  EB                  EX      DE,HL
 1021 EE32  CD EA4F             CALL    NONBLANK        ;get next non blank character.
 1022 EE35  FE 3D               CP      '='             ;only allow an '=' or '_' seperator.
 1023 EE37  CA EE3F             JP      Z,RENAME1
 1024 EE3A  FE 5F               CP      '_'
 1025 EE3C  C2 EE73             JP      NZ,RENAME5
 1026 EE3F  EB          RENAME1:EX      DE,HL
 1027 EE40  23                  INC     HL              ;ok, skip seperator.
 1028 EE41  22 E888             LD      (INPOINT),HL    ;save input line pointer.
 1029 EE44  CD EA5E             CALL    CONVFST         ;convert this second file name now.
 1030 EE47  C2 EE73             JP      NZ,RENAME5      ;again, no wild cards.
 1031 EE4A  F1                  POP     AF              ;if a drive was specified, then it
 1032 EE4B  47                  LD      B,A             ;must be the same as before.
 1033 EE4C  21 EFF0             LD      HL,CHGDRV
 1034 EE4F  7E                  LD      A,(HL)
 1035 EE50  B7                  OR      A
 1036 EE51  CA EE59             JP      Z,RENAME2
 1037 EE54  B8                  CP      B
 1038 EE55  70                  LD      (HL),B
 1039 EE56  C2 EE73             JP      NZ,RENAME5      ;they were different, error.
 1040 EE59  70          RENAME2:LD      (HL),B          ;       reset as per the first file specification.
 1041 EE5A  AF                  XOR     A
 1042 EE5B  32 EFCD             LD      (FCB),A         ;clear the drive byte of the fcb.
 1043 EE5E  CD E8E9     RENAME3:CALL    SRCHFCB         ;and go look for second file.
 1044 EE61  CA EE6D             JP      Z,RENAME4       ;doesn't exist?
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  19
BDOS22  Z80

 1045 EE64  11 EFCD             LD      DE,FCB
 1046 EE67  CD E90E             CALL    RENAM           ;ok, rename the file.
 1047 EE6A  C3 EF86             JP      GETBACK
 1048                   ;
 1049                   ;   Process rename errors here.
 1050                   ;
 1051 EE6D  CD EBEA     RENAME4:CALL    NONE            ;file not there.
 1052 EE70  C3 EF86             JP      GETBACK
 1053 EE73  CD EC66     RENAME5:CALL    RESETDR         ;bad command format.
 1054 EE76  C3 EA09             JP      SYNERR
 1055 EE79  01 EE82     RENAME6:LD      BC,EXISTS       ;destination file already exists.
 1056 EE7C  CD E8A7             CALL    PLINE
 1057 EE7F  C3 EF86             JP      GETBACK
 1058 EE82  46 69 6C 65 EXISTS:  DB     "File exists"
 1059 EE8D  00                   DB     0
 1060                   ;
 1061                   ;**************************************************************
 1062                   ;*
 1063                   ;*             U S E R   C O M M A N D
 1064                   ;*
 1065                   ;**************************************************************
 1066                   ;
 1067 EE8E  CD EBF8     USER:   CALL    DECODE          ;get numeric value following command.
 1068 EE91  FE 10               CP      16              ;legal user number?
 1069 EE93  D2 EA09             JP      NC,SYNERR
 1070 EE96  5F                  LD      E,A             ;yes but is there anything else?
 1071 EE97  3A EFCE             LD      A,(FCB+1)
 1072 EE9A  FE 20               CP      ' '
 1073 EE9C  CA EA09             JP      Z,SYNERR        ;yes, that is not allowed.
 1074 EE9F  CD E915             CALL    GETSETUC        ;ok, set user code.
 1075 EEA2  C3 EF89             JP      GETBACK1
 1076                   ;
 1077                   ;**************************************************************
 1078                   ;*
 1079                   ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
 1080                   ;*
 1081                   ;**************************************************************
 1082                   ;
 1083 EEA5  CD E9F5     UNKNOWN:CALL    VERIFY          ;check for valid system (why?).
 1084 EEA8  3A EFCE             LD      A,(FCB+1)       ;anything to execute?
 1085 EEAB  FE 20               CP      ' '
 1086 EEAD  C2 EEC4             JP      NZ,UNKWN1
 1087 EEB0  3A EFF0             LD      A,(CHGDRV)      ;nope, only a drive change?
 1088 EEB3  B7                  OR      A
 1089 EEB4  CA EF89             JP      Z,GETBACK1      ;neither???
 1090 EEB7  3D                  DEC     A
 1091 EEB8  32 EFEF             LD      (CDRIVE),A      ;ok, store new drive.
 1092 EEBB  CD E929             CALL    MOVECD          ;set (TDRIVE) also.
 1093 EEBE  CD E8BD             CALL    DSKSEL          ;and select this drive.
 1094 EEC1  C3 EF89             JP      GETBACK1        ;then return.
 1095                   ;
 1096                   ;   Here a file name was typed. Prepare to execute it.
 1097                   ;
 1098 EEC4  11 EFD6     UNKWN1: LD      DE,FCB+9        ;an extension specified?
 1099 EEC7  1A                  LD      A,(DE)
 1100 EEC8  FE 20               CP      ' '
 1101 EECA  C2 EA09             JP      NZ,SYNERR       ;yes, not allowed.
 1102 EECD  D5          UNKWN2: PUSH    DE
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  20
BDOS22  Z80

 1103 EECE  CD EC54             CALL    DSELECT         ;select specified drive.
 1104 EED1  D1                  POP     DE
 1105 EED2  21 EF83             LD      HL,COMFILE      ;set the extension to 'COM'.
 1106 EED5  CD EC40             CALL    MOVE3
 1107 EED8  CD E8D0             CALL    OPENFCB         ;and open this file.
 1108 EEDB  CA EF6B             JP      Z,UNKWN9        ;not present?
 1109                   ;
 1110                   ;   Load in the program.
 1111                   ;
 1112 EEDE  21 0100             LD      HL,TBASE        ;store the program starting here.
 1113 EEE1  E5          UNKWN3: PUSH    HL
 1114 EEE2  EB                  EX      DE,HL
 1115 EEE3  CD E9D8             CALL    DMASET          ;set transfer address.
 1116 EEE6  11 EFCD             LD      DE,FCB          ;and read the next record.
 1117 EEE9  CD E8F9             CALL    RDREC
 1118 EEEC  C2 EF01             JP      NZ,UNKWN4       ;end of file or read error?
 1119 EEEF  E1                  POP     HL              ;nope, bump pointer for next sector.
 1120 EEF0  11 0080             LD      DE,128
 1121 EEF3  19                  ADD     HL,DE
 1122 EEF4  11 E800             LD      DE,CBASE        ;enough room for the whole file?
 1123 EEF7  7D                  LD      A,L
 1124 EEF8  93                  SUB     E
 1125 EEF9  7C                  LD      A,H
 1126 EEFA  9A                  SBC     A,D
 1127 EEFB  D2 EF71             JP      NC,UNKWN0       ;no, it can't fit.
 1128 EEFE  C3 EEE1             JP      UNKWN3
 1129                   ;
 1130                   ;   Get here after finished reading.
 1131                   ;
 1132 EF01  E1          UNKWN4: POP     HL
 1133 EF02  3D                  DEC     A               ;normal end of file?
 1134 EF03  C2 EF71             JP      NZ,UNKWN0
 1135 EF06  CD EC66             CALL    RESETDR         ;yes, reset previous drive.
 1136 EF09  CD EA5E             CALL    CONVFST         ;convert the first file name that follows
 1137 EF0C  21 EFF0             LD      HL,CHGDRV       ;command name.
 1138 EF0F  E5                  PUSH    HL
 1139 EF10  7E                  LD      A,(HL)          ;set drive code in default fcb.
 1140 EF11  32 EFCD             LD      (FCB),A
 1141 EF14  3E 10               LD      A,16            ;put second name 16 bytes later.
 1142 EF16  CD EA60             CALL    CONVERT         ;convert second file name.
 1143 EF19  E1                  POP     HL
 1144 EF1A  7E                  LD      A,(HL)          ;and set the drive for this second file.
 1145 EF1B  32 EFDD             LD      (FCB+16),A
 1146 EF1E  AF                  XOR     A               ;clear record byte in fcb.
 1147 EF1F  32 EFED             LD      (FCB+32),A
 1148 EF22  11 005C             LD      DE,TFCB         ;move it into place at(005Ch).
 1149 EF25  21 EFCD             LD      HL,FCB
 1150 EF28  06 21               LD      B,33
 1151 EF2A  CD EC42             CALL    HL2DE
 1152 EF2D  21 E808             LD      HL,INBUFF+2     ;now move the remainder of the input
 1153 EF30  7E          UNKWN5: LD      A,(HL)          ;line down to (0080h). Look for a non blank.
 1154 EF31  B7                  OR      A               ;or a null.
 1155 EF32  CA EF3E             JP      Z,UNKWN6
 1156 EF35  FE 20               CP      ' '
 1157 EF37  CA EF3E             JP      Z,UNKWN6
 1158 EF3A  23                  INC     HL
 1159 EF3B  C3 EF30             JP      UNKWN5
 1160                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  21
BDOS22  Z80

 1161                   ;   Do the line move now. It ends in a null byte.
 1162                   ;
 1163 EF3E  06 00       UNKWN6: LD      B,0             ;keep a character count.
 1164 EF40  11 0081             LD      DE,TBUFF+1      ;data gets put here.
 1165 EF43  7E          UNKWN7: LD      A,(HL)          ;move it now.
 1166 EF44  12                  LD      (DE),A
 1167 EF45  B7                  OR      A
 1168 EF46  CA EF4F             JP      Z,UNKWN8
 1169 EF49  04                  INC     B
 1170 EF4A  23                  INC     HL
 1171 EF4B  13                  INC     DE
 1172 EF4C  C3 EF43             JP      UNKWN7
 1173 EF4F  78          UNKWN8: LD      A,B             ;now store the character count.
 1174 EF50  32 0080             LD      (TBUFF),A
 1175 EF53  CD E898             CALL    CRLF            ;clean up the screen.
 1176 EF56  CD E9D5             CALL    STDDMA          ;set standard transfer address.
 1177 EF59  CD E91A             CALL    SETCDRV         ;reset current drive.
 1178 EF5C  CD 0100             CALL    TBASE           ;and execute the program.
 1179                   ;
 1180                   ;   Transiant programs return here (or reboot).
 1181                   ;
 1182 EF5F  31 EFAB             LD      SP,BATCH        ;set stack first off.
 1183 EF62  CD E929             CALL    MOVECD          ;move current drive into place (TDRIVE).
 1184 EF65  CD E8BD             CALL    DSKSEL          ;and reselect it.
 1185 EF68  C3 EB82             JP      CMMND1          ;back to comand mode.
 1186                   ;
 1187                   ;   Get here if some error occured.
 1188                   ;
 1189 EF6B  CD EC66     UNKWN9: CALL    RESETDR         ;inproper format.
 1190 EF6E  C3 EA09             JP      SYNERR
 1191 EF71  01 EF7A     UNKWN0: LD      BC,BADLOAD      ;read error or won't fit.
 1192 EF74  CD E8A7             CALL    PLINE
 1193 EF77  C3 EF86             JP      GETBACK
 1194 EF7A  42 61 64 20 BADLOAD: DB     "Bad load"
 1195 EF82  00                   DB     0
 1196 EF83  43 4F 4D    COMFILE: DB     "COM"           ;command file extension.
 1197                   ;
 1198                   ;   Get here to return to command level. We will reset the
 1199                   ; previous active drive and then either return to command
 1200                   ; level directly or print error message and then return.
 1201                   ;
 1202 EF86  CD EC66     GETBACK:CALL    RESETDR         ;reset previous drive.
 1203 EF89  CD EA5E     GETBACK1: CALL  CONVFST         ;convert first name in (FCB).
 1204 EF8C  3A EFCE             LD      A,(FCB+1)       ;if this was just a drive change request,
 1205 EF8F  D6 20               SUB     ' '             ;make sure it was valid.
 1206 EF91  21 EFF0             LD      HL,CHGDRV
 1207 EF94  B6                  OR      (HL)
 1208 EF95  C2 EA09             JP      NZ,SYNERR
 1209 EF98  C3 EB82             JP      CMMND1          ;ok, return to command level.
 1210                   ;
 1211                   ;   ccp stack area.
 1212                   ;
 1213 EF9B  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1214         EFAB      CCPSTACK  EQU   $       ;end of ccp stack area.
 1215                   ;
 1216                   ;   Batch (or SUBMIT) processing information storage.
 1217                   ;
 1218 EFAB  00          BATCH:   DB     0               ;batch mode flag (0=not active).
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  22
BDOS22  Z80

 1219 EFAC  00          BATCHFCB:  DB   0,
 1220 EFAD  24 24 24 20          DB   "$$$     SUB"
 1221 EFB8  00 00 00 00          DB 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1222                   ;
 1223                   ;   File control block setup by the CCP.
 1224                   ;
 1225 EFCD  00          FCB:     DB     0
 1226 EFCE  20 20 20 20          DB     "           "
 1227 EFD9  00 00 00 00          DB     0,0,0,0,0
 1228 EFDE  20 20 20 20          DB     "           "
 1229 EFE9  00 00 00 00          DB     0,0,0,0,0
 1230 EFEE  00          RTNCODE: DB     0               ;status returned from bdos call.
 1231 EFEF  00          CDRIVE:  DB     0               ;currently active drive.
 1232 EFF0  00          CHGDRV:  DB     0               ;change in drives flag (0=no change).
 1233 EFF1  0000        NBYTES:  DW     0               ;byte counter used by TYPE.
 1234                   ;
 1235                   ;   Room for expansion?
 1236                   ;
 1237 EFF3  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0
 1238                   ;
 1239                   ;   Note that the following six bytes must match those at
 1240                   ; (PATTRN1) or cp/m will HALT. Why?
 1241                   ;
 1242 F000  00 16 00 00 PATTRN2: DB     0,22,0,0,0,0    ;(* serial number bytes *).
 1243                   ;
 1244                   ;**************************************************************
 1245                   ;*
 1246                   ;*                    B D O S   E N T R Y
 1247                   ;*
 1248                   ;**************************************************************
 1249                   ;
 1250 F006  C3 F011     FBASE:  JP      FBASE1
 1251                   ;
 1252                   ;   Bdos error table.
 1253                   ;
 1254 F009  F099        BADSCTR: DW     ERROR1          ;bad sector on read or write.
 1255 F00B  F0A5        BADSLCT: DW     ERROR2          ;bad disk select.
 1256 F00D  F0AB        RODISK:  DW     ERROR3          ;disk is read only.
 1257 F00F  F0B1        ROFILE:  DW     ERROR4          ;file is read only.
 1258                   ;
 1259                   ;   Entry into bdos. (DE) or (E) are the parameters passed. The
 1260                   ; function number desired is in register (C).
 1261                   ;
 1262 F011  EB          FBASE1: EX      DE,HL           ;save the (DE) parameters.
 1263 F012  22 F343             LD      (PARAMS),HL
 1264 F015  EB                  EX      DE,HL
 1265 F016  7B                  LD      A,E             ;and save register (E) in particular.
 1266 F017  32 FDD6             LD      (EPARAM),A
 1267 F01A  21 0000             LD      HL,0
 1268 F01D  22 F345             LD      (STATUS),HL     ;clear return status.
 1269 F020  39                  ADD     HL,SP
 1270 F021  22 F30F             LD      (USRSTACK),HL   ;save users stack pointer.
 1271 F024  31 F341             LD      SP,STKAREA      ;and set our own.
 1272 F027  AF                  XOR     A               ;clear auto select storage space.
 1273 F028  32 FDE0             LD      (AUTOFLAG),A
 1274 F02B  32 FDDE             LD      (AUTO),A
 1275 F02E  21 FD74             LD      HL,GOBACK       ;set return address.
 1276 F031  E5                  PUSH    HL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  23
BDOS22  Z80

 1277 F032  79                  LD      A,C             ;get function number.
 1278 F033  FE 29               CP      NFUNCTS         ;valid function number?
 1279 F035  D0                  RET     NC
 1280 F036  4B                  LD      C,E             ;keep single register function here.
 1281 F037  21 F047             LD      HL,FUNCTNS      ;now look thru the function table.
 1282 F03A  5F                  LD      E,A
 1283 F03B  16 00               LD      D,0             ;(DE)=function number.
 1284 F03D  19                  ADD     HL,DE
 1285 F03E  19                  ADD     HL,DE           ;(HL)=(start of table)+2*(function number).
 1286 F03F  5E                  LD      E,(HL)
 1287 F040  23                  INC     HL
 1288 F041  56                  LD      D,(HL)          ;now (DE)=address for this function.
 1289 F042  2A F343             LD      HL,(PARAMS)     ;retrieve parameters.
 1290 F045  EB                  EX      DE,HL           ;now (DE) has the original parameters.
 1291 F046  E9                  JP      (HL)            ;execute desired function.
 1292                   ;
 1293                   ;   BDOS function jump table.
 1294                   ;
 1295         0029      NFUNCTS  EQU    41              ;number of functions in followin table.
 1296                   ;
 1297 F047  FE03  F2C8  FUNCTNS: DW     WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
 1298 F057  F2F3  F2F8           DW     SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
 1299 F067  FCA5  FCAB           DW     CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
 1300 F075  FCF5  FCFE           DW     RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
 1301 F085  FD26  FD2D           DW     GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
 1302 F095  F304  FD9B           DW     RTN,WTSPECL
 1303                   ;
 1304                   ;   Bdos error message section.
 1305                   ;
 1306 F099  21 F0CA     ERROR1: LD      HL,BADSEC       ;bad sector message.
 1307 F09C  CD F0E5             CALL    PRTERR          ;print it and get a 1 char responce.
 1308 F09F  FE 03               CP      CNTRLC          ;re-boot request (control-c)?
 1309 F0A1  CA 0000             JP      Z,0             ;yes.
 1310 F0A4  C9                  RET                     ;no, return to retry i/o function.
 1311                   ;
 1312 F0A5  21 F0D5     ERROR2: LD      HL,BADSEL       ;bad drive selected.
 1313 F0A8  C3 F0B4             JP      ERROR5
 1314                   ;
 1315 F0AB  21 F0E1     ERROR3: LD      HL,DISKRO       ;disk is read only.
 1316 F0AE  C3 F0B4             JP      ERROR5
 1317                   ;
 1318 F0B1  21 F0DC     ERROR4: LD      HL,FILERO       ;file is read only.
 1319                   ;
 1320 F0B4  CD F0E5     ERROR5: CALL    PRTERR
 1321 F0B7  C3 0000             JP      0               ;always reboot on these errors.
 1322                   ;
 1323 F0BA  42 64 6F 73 BDOSERR: DB     "Bdos Err On "
 1324 F0C6  20 3A 20 24 BDOSDRV: DB     " : $"
 1325 F0CA  42 61 64 20 BADSEC:  DB     "Bad Sector$"
 1326 F0D5  53 65 6C 65 BADSEL:  DB     "Select$"
 1327 F0DC  46 69 6C 65 FILERO:  DB     "File "
 1328 F0E1  52 2F 4F 24 DISKRO:  DB     "R/O$"
 1329                   ;
 1330                   ;   Print bdos error message.
 1331                   ;
 1332 F0E5  E5          PRTERR: PUSH    HL              ;save second message pointer.
 1333 F0E6  CD F1C9             CALL    OUTCRLF         ;send (cr)(lf).
 1334 F0E9  3A F342             LD      A,(ACTIVE)      ;get active drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  24
BDOS22  Z80

 1335 F0EC  C6 41               ADD     A,'A'           ;make ascii.
 1336 F0EE  32 F0C6             LD      (BDOSDRV),A     ;and put in message.
 1337 F0F1  01 F0BA             LD      BC,BDOSERR      ;and print it.
 1338 F0F4  CD F1D3             CALL    PRTMESG
 1339 F0F7  C1                  POP     BC              ;print second message line now.
 1340 F0F8  CD F1D3             CALL    PRTMESG
 1341                   ;
 1342                   ;   Get an input character. We will check our 1 character
 1343                   ; buffer first. This may be set by the console status routine.
 1344                   ;
 1345 F0FB  21 F30E     GETCHAR:LD      HL,CHARBUF      ;check character buffer.
 1346 F0FE  7E                  LD      A,(HL)          ;anything present already?
 1347 F0FF  36 00               LD      (HL),0          ;...either case clear it.
 1348 F101  B7                  OR      A
 1349 F102  C0                  RET     NZ              ;yes, use it.
 1350 F103  C3 FE09             JP      CONIN           ;nope, go get a character responce.
 1351                   ;
 1352                   ;   Input and echo a character.
 1353                   ;
 1354 F106  CD F0FB     GETECHO:CALL    GETCHAR         ;input a character.
 1355 F109  CD F114             CALL    CHKCHAR         ;carriage control?
 1356 F10C  D8                  RET     C               ;no, a regular control char so don't echo.
 1357 F10D  F5                  PUSH    AF              ;ok, save character now.
 1358 F10E  4F                  LD      C,A
 1359 F10F  CD F190             CALL    OUTCON          ;and echo it.
 1360 F112  F1                  POP     AF              ;get character and return.
 1361 F113  C9                  RET     
 1362                   ;
 1363                   ;   Check character in (A). Set the zero flag on a carriage
 1364                   ; control character and the carry flag on any other control
 1365                   ; character.
 1366                   ;
 1367 F114  FE 0D       CHKCHAR:CP      CR              ;check for carriage return, line feed, backspace,
 1368 F116  C8                  RET     Z               ;or a tab.
 1369 F117  FE 0A               CP      LF
 1370 F119  C8                  RET     Z
 1371 F11A  FE 09               CP      TAB
 1372 F11C  C8                  RET     Z
 1373 F11D  FE 08               CP      BS
 1374 F11F  C8                  RET     Z
 1375 F120  FE 20               CP      ' '             ;other control char? Set carry flag.
 1376 F122  C9                  RET     
 1377                   ;
 1378                   ;   Check the console during output. Halt on a control-s, then
 1379                   ; reboot on a control-c. If anything else is ready, clear the
 1380                   ; zero flag and return (the calling routine may want to do
 1381                   ; something).
 1382                   ;
 1383 F123  3A F30E     CKCONSOL: LD    A,(CHARBUF)     ;check buffer.
 1384 F126  B7                  OR      A               ;if anything, just return without checking.
 1385 F127  C2 F145             JP      NZ,CKCON2
 1386 F12A  CD FE06             CALL    CONST           ;nothing in buffer. Check console.
 1387 F12D  E6 01               AND     01H             ;look at bit 0.
 1388 F12F  C8                  RET     Z               ;return if nothing.
 1389 F130  CD FE09             CALL    CONIN           ;ok, get it.
 1390 F133  FE 13               CP      CNTRLS          ;if not control-s, return with zero cleared.
 1391 F135  C2 F142             JP      NZ,CKCON1
 1392 F138  CD FE09             CALL    CONIN           ;halt processing until another char
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  25
BDOS22  Z80

 1393 F13B  FE 03               CP      CNTRLC          ;is typed. Control-c?
 1394 F13D  CA 0000             JP      Z,0             ;yes, reboot now.
 1395 F140  AF                  XOR     A               ;no, just pretend nothing was ever ready.
 1396 F141  C9                  RET     
 1397 F142  32 F30E     CKCON1: LD      (CHARBUF),A     ;save character in buffer for later processing.
 1398 F145  3E 01       CKCON2: LD      A,1             ;set (A) to non zero to mean something is ready.
 1399 F147  C9                  RET     
 1400                   ;
 1401                   ;   Output (C) to the screen. If the printer flip-flop flag
 1402                   ; is set, we will send character to printer also. The console
 1403                   ; will be checked in the process.
 1404                   ;
 1405 F148  3A F30A     OUTCHAR:LD      A,(OUTFLAG)     ;check output flag.
 1406 F14B  B7                  OR      A               ;anything and we won't generate output.
 1407 F14C  C2 F162             JP      NZ,OUTCHR1
 1408 F14F  C5                  PUSH    BC
 1409 F150  CD F123             CALL    CKCONSOL        ;check console (we don't care whats there).
 1410 F153  C1                  POP     BC
 1411 F154  C5                  PUSH    BC
 1412 F155  CD FE0C             CALL    CONOUT          ;output (C) to the screen.
 1413 F158  C1                  POP     BC
 1414 F159  C5                  PUSH    BC
 1415 F15A  3A F30D             LD      A,(PRTFLAG)     ;check printer flip-flop flag.
 1416 F15D  B7                  OR      A
 1417 F15E  C4 FE0F             CALL    NZ,LIST         ;print it also if non-zero.
 1418 F161  C1                  POP     BC
 1419 F162  79          OUTCHR1:LD      A,C             ;update cursors position.
 1420 F163  21 F30C             LD      HL,CURPOS
 1421 F166  FE 7F               CP      DEL             ;rubouts don't do anything here.
 1422 F168  C8                  RET     Z
 1423 F169  34                  INC     (HL)            ;bump line pointer.
 1424 F16A  FE 20               CP      ' '             ;and return if a normal character.
 1425 F16C  D0                  RET     NC
 1426 F16D  35                  DEC     (HL)            ;restore and check for the start of the line.
 1427 F16E  7E                  LD      A,(HL)
 1428 F16F  B7                  OR      A
 1429 F170  C8                  RET     Z               ;ingnore control characters at the start of the line.
 1430 F171  79                  LD      A,C
 1431 F172  FE 08               CP      BS              ;is it a backspace?
 1432 F174  C2 F179             JP      NZ,OUTCHR2
 1433 F177  35                  DEC     (HL)            ;yes, backup pointer.
 1434 F178  C9                  RET     
 1435 F179  FE 0A       OUTCHR2:CP      LF              ;is it a line feed?
 1436 F17B  C0                  RET     NZ              ;ignore anything else.
 1437 F17C  36 00               LD      (HL),0          ;reset pointer to start of line.
 1438 F17E  C9                  RET     
 1439                   ;
 1440                   ;   Output (A) to the screen. If it is a control character
 1441                   ; (other than carriage control), use ^x format.
 1442                   ;
 1443 F17F  79          SHOWIT: LD      A,C
 1444 F180  CD F114             CALL    CHKCHAR         ;check character.
 1445 F183  D2 F190             JP      NC,OUTCON       ;not a control, use normal output.
 1446 F186  F5                  PUSH    AF
 1447 F187  0E 5E               LD      C,'^'           ;for a control character, preceed it with '^'.
 1448 F189  CD F148             CALL    OUTCHAR
 1449 F18C  F1                  POP     AF
 1450 F18D  F6 40               OR      '@'             ;and then use the letter equivelant.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  26
BDOS22  Z80

 1451 F18F  4F                  LD      C,A
 1452                   ;
 1453                   ;   Function to output (C) to the console device and expand tabs
 1454                   ; if necessary.
 1455                   ;
 1456 F190  79          OUTCON: LD      A,C
 1457 F191  FE 09               CP      TAB             ;is it a tab?
 1458 F193  C2 F148             JP      NZ,OUTCHAR      ;use regular output.
 1459 F196  0E 20       OUTCON1:LD      C,' '           ;yes it is, use spaces instead.
 1460 F198  CD F148             CALL    OUTCHAR
 1461 F19B  3A F30C             LD      A,(CURPOS)      ;go until the cursor is at a multiple of 8
 1462                   
 1463 F19E  E6 07               AND     07H             ;position.
 1464 F1A0  C2 F196             JP      NZ,OUTCON1
 1465 F1A3  C9                  RET     
 1466                   ;
 1467                   ;   Echo a backspace character. Erase the prevoius character
 1468                   ; on the screen.
 1469                   ;
 1470 F1A4  CD F1AC     BACKUP: CALL    BACKUP1         ;backup the screen 1 place.
 1471 F1A7  0E 20               LD      C,' '           ;then blank that character.
 1472 F1A9  CD FE0C             CALL    CONOUT
 1473 F1AC  0E 08       BACKUP1:LD      C,BS            ;then back space once more.
 1474 F1AE  C3 FE0C             JP      CONOUT
 1475                   ;
 1476                   ;   Signal a deleted line. Print a '#' at the end and start
 1477                   ; over.
 1478                   ;
 1479 F1B1  0E 23       NEWLINE:LD      C,'#'
 1480 F1B3  CD F148             CALL    OUTCHAR         ;print this.
 1481 F1B6  CD F1C9             CALL    OUTCRLF         ;start new line.
 1482 F1B9  3A F30C     NEWLN1: LD      A,(CURPOS)      ;move the cursor to the starting position.
 1483 F1BC  21 F30B             LD      HL,STARTING
 1484 F1BF  BE                  CP      (HL)
 1485 F1C0  D0                  RET     NC              ;there yet?
 1486 F1C1  0E 20               LD      C,' '
 1487 F1C3  CD F148             CALL    OUTCHAR         ;nope, keep going.
 1488 F1C6  C3 F1B9             JP      NEWLN1
 1489                   ;
 1490                   ;   Output a (cr) (lf) to the console device (screen).
 1491                   ;
 1492 F1C9  0E 0D       OUTCRLF:LD      C,CR
 1493 F1CB  CD F148             CALL    OUTCHAR
 1494 F1CE  0E 0A               LD      C,LF
 1495 F1D0  C3 F148             JP      OUTCHAR
 1496                   ;
 1497                   ;   Print message pointed to by (BC). It will end with a '$'.
 1498                   ;
 1499 F1D3  0A          PRTMESG:LD      A,(BC)          ;check for terminating character.
 1500 F1D4  FE 24               CP      '$'
 1501 F1D6  C8                  RET     Z
 1502 F1D7  03                  INC     BC
 1503 F1D8  C5                  PUSH    BC              ;otherwise, bump pointer and print it.
 1504 F1D9  4F                  LD      C,A
 1505 F1DA  CD F190             CALL    OUTCON
 1506 F1DD  C1                  POP     BC
 1507 F1DE  C3 F1D3             JP      PRTMESG
 1508                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  27
BDOS22  Z80

 1509                   ;   Function to execute a buffered read.
 1510                   ;
 1511 F1E1  3A F30C     RDBUFF: LD      A,(CURPOS)      ;use present location as starting one.
 1512 F1E4  32 F30B             LD      (STARTING),A
 1513 F1E7  2A F343             LD      HL,(PARAMS)     ;get the maximum buffer space.
 1514 F1EA  4E                  LD      C,(HL)
 1515 F1EB  23                  INC     HL              ;point to first available space.
 1516 F1EC  E5                  PUSH    HL              ;and save.
 1517 F1ED  06 00               LD      B,0             ;keep a character count.
 1518 F1EF  C5          RDBUF1: PUSH    BC
 1519 F1F0  E5                  PUSH    HL
 1520 F1F1  CD F0FB     RDBUF2: CALL    GETCHAR         ;get the next input character.
 1521 F1F4  E6 7F               AND     7FH             ;strip bit 7.
 1522 F1F6  E1                  POP     HL              ;reset registers.
 1523 F1F7  C1                  POP     BC
 1524 F1F8  FE 0D               CP      CR              ;en of the line?
 1525 F1FA  CA F2C1             JP      Z,RDBUF17
 1526 F1FD  FE 0A               CP      LF
 1527 F1FF  CA F2C1             JP      Z,RDBUF17
 1528 F202  FE 08               CP      BS              ;how about a backspace?
 1529 F204  C2 F216             JP      NZ,RDBUF3
 1530 F207  78                  LD      A,B             ;yes, but ignore at the beginning of the line.
 1531 F208  B7                  OR      A
 1532 F209  CA F1EF             JP      Z,RDBUF1
 1533 F20C  05                  DEC     B               ;ok, update counter.
 1534 F20D  3A F30C             LD      A,(CURPOS)      ;if we backspace to the start of the line,
 1535 F210  32 F30A             LD      (OUTFLAG),A     ;treat as a cancel (control-x).
 1536 F213  C3 F270             JP      RDBUF10
 1537 F216  FE 7F       RDBUF3: CP      DEL             ;user typed a rubout?
 1538 F218  C2 F226             JP      NZ,RDBUF4
 1539 F21B  78                  LD      A,B             ;ignore at the start of the line.
 1540 F21C  B7                  OR      A
 1541 F21D  CA F1EF             JP      Z,RDBUF1
 1542 F220  7E                  LD      A,(HL)          ;ok, echo the prevoius character.
 1543 F221  05                  DEC     B               ;and reset pointers (counters).
 1544 F222  2B                  DEC     HL
 1545 F223  C3 F2A9             JP      RDBUF15
 1546 F226  FE 05       RDBUF4: CP      CNTRLE          ;physical end of line?
 1547 F228  C2 F237             JP      NZ,RDBUF5
 1548 F22B  C5                  PUSH    BC              ;yes, do it.
 1549 F22C  E5                  PUSH    HL
 1550 F22D  CD F1C9             CALL    OUTCRLF
 1551 F230  AF                  XOR     A               ;and update starting position.
 1552 F231  32 F30B             LD      (STARTING),A
 1553 F234  C3 F1F1             JP      RDBUF2
 1554 F237  FE 10       RDBUF5: CP      CNTRLP          ;control-p?
 1555 F239  C2 F248             JP      NZ,RDBUF6
 1556 F23C  E5                  PUSH    HL              ;yes, flip the print flag filp-flop byte.
 1557 F23D  21 F30D             LD      HL,PRTFLAG
 1558 F240  3E 01               LD      A,1             ;PRTFLAG=1-PRTFLAG
 1559 F242  96                  SUB     (HL)
 1560 F243  77                  LD      (HL),A
 1561 F244  E1                  POP     HL
 1562 F245  C3 F1EF             JP      RDBUF1
 1563 F248  FE 18       RDBUF6: CP      CNTRLX          ;control-x (cancel)?
 1564 F24A  C2 F25F             JP      NZ,RDBUF8
 1565 F24D  E1                  POP     HL
 1566 F24E  3A F30B     RDBUF7: LD      A,(STARTING)    ;yes, backup the cursor to here.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  28
BDOS22  Z80

 1567 F251  21 F30C             LD      HL,CURPOS
 1568 F254  BE                  CP      (HL)
 1569 F255  D2 F1E1             JP      NC,RDBUFF       ;done yet?
 1570 F258  35                  DEC     (HL)            ;no, decrement pointer and output back up one space.
 1571 F259  CD F1A4             CALL    BACKUP
 1572 F25C  C3 F24E             JP      RDBUF7
 1573 F25F  FE 15       RDBUF8: CP      CNTRLU          ;cntrol-u (cancel line)?
 1574 F261  C2 F26B             JP      NZ,RDBUF9
 1575 F264  CD F1B1             CALL    NEWLINE         ;start a new line.
 1576 F267  E1                  POP     HL
 1577 F268  C3 F1E1             JP      RDBUFF
 1578 F26B  FE 12       RDBUF9: CP      CNTRLR          ;control-r?
 1579 F26D  C2 F2A6             JP      NZ,RDBUF14
 1580 F270  C5          RDBUF10:PUSH    BC              ;yes, start a new line and retype the old one.
 1581 F271  CD F1B1             CALL    NEWLINE
 1582 F274  C1                  POP     BC
 1583 F275  E1                  POP     HL
 1584 F276  E5                  PUSH    HL
 1585 F277  C5                  PUSH    BC
 1586 F278  78          RDBUF11:LD      A,B             ;done whole line yet?
 1587 F279  B7                  OR      A
 1588 F27A  CA F28A             JP      Z,RDBUF12
 1589 F27D  23                  INC     HL              ;nope, get next character.
 1590 F27E  4E                  LD      C,(HL)
 1591 F27F  05                  DEC     B               ;count it.
 1592 F280  C5                  PUSH    BC
 1593 F281  E5                  PUSH    HL
 1594 F282  CD F17F             CALL    SHOWIT          ;and display it.
 1595 F285  E1                  POP     HL
 1596 F286  C1                  POP     BC
 1597 F287  C3 F278             JP      RDBUF11
 1598 F28A  E5          RDBUF12:PUSH    HL              ;done with line. If we were displaying
 1599 F28B  3A F30A             LD      A,(OUTFLAG)     ;then update cursor position.
 1600 F28E  B7                  OR      A
 1601 F28F  CA F1F1             JP      Z,RDBUF2
 1602 F292  21 F30C             LD      HL,CURPOS       ;because this line is shorter, we must
 1603 F295  96                  SUB     (HL)            ;back up the cursor (not the screen however)
 1604 F296  32 F30A             LD      (OUTFLAG),A     ;some number of positions.
 1605 F299  CD F1A4     RDBUF13:CALL    BACKUP          ;note that as long as (OUTFLAG) is non
 1606 F29C  21 F30A             LD      HL,OUTFLAG      ;zero, the screen will not be changed.
 1607 F29F  35                  DEC     (HL)
 1608 F2A0  C2 F299             JP      NZ,RDBUF13
 1609 F2A3  C3 F1F1             JP      RDBUF2          ;now just get the next character.
 1610                   ;
 1611                   ;   Just a normal character, put this in our buffer and echo.
 1612                   ;
 1613 F2A6  23          RDBUF14:INC     HL
 1614 F2A7  77                  LD      (HL),A          ;store character.
 1615 F2A8  04                  INC     B               ;and count it.
 1616 F2A9  C5          RDBUF15:PUSH    BC
 1617 F2AA  E5                  PUSH    HL
 1618 F2AB  4F                  LD      C,A             ;echo it now.
 1619 F2AC  CD F17F             CALL    SHOWIT
 1620 F2AF  E1                  POP     HL
 1621 F2B0  C1                  POP     BC
 1622 F2B1  7E                  LD      A,(HL)          ;was it an abort request?
 1623 F2B2  FE 03               CP      CNTRLC          ;control-c abort?
 1624 F2B4  78                  LD      A,B
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  29
BDOS22  Z80

 1625 F2B5  C2 F2BD             JP      NZ,RDBUF16
 1626 F2B8  FE 01               CP      1               ;only if at start of line.
 1627 F2BA  CA 0000             JP      Z,0
 1628 F2BD  B9          RDBUF16:CP      C               ;nope, have we filled the buffer?
 1629 F2BE  DA F1EF             JP      C,RDBUF1
 1630 F2C1  E1          RDBUF17:POP     HL              ;yes end the line and return.
 1631 F2C2  70                  LD      (HL),B
 1632 F2C3  0E 0D               LD      C,CR
 1633 F2C5  C3 F148             JP      OUTCHAR         ;output (cr) and return.
 1634                   ;
 1635                   ;   Function to get a character from the console device.
 1636                   ;
 1637 F2C8  CD F106     GETCON: CALL    GETECHO         ;get and echo.
 1638 F2CB  C3 F301             JP      SETSTAT         ;save status and return.
 1639                   ;
 1640                   ;   Function to get a character from the tape reader device.
 1641                   ;
 1642 F2CE  CD FE15     GETRDR: CALL    READER          ;get a character from reader, set status and return.
 1643 F2D1  C3 F301             JP      SETSTAT
 1644                   ;
 1645                   ;  Function to perform direct console i/o. If (C) contains (FF)
 1646                   ; then this is an input request. If (C) contains (FE) then
 1647                   ; this is a status request. Otherwise we are to output (C).
 1648                   ;
 1649 F2D4  79          DIRCIO: LD      A,C             ;test for (FF).
 1650 F2D5  3C                  INC     A
 1651 F2D6  CA F2E0             JP      Z,DIRC1
 1652 F2D9  3C                  INC     A               ;test for (FE).
 1653 F2DA  CA FE06             JP      Z,CONST
 1654 F2DD  C3 FE0C             JP      CONOUT          ;just output (C).
 1655 F2E0  CD FE06     DIRC1:  CALL    CONST           ;this is an input request.
 1656 F2E3  B7                  OR      A
 1657 F2E4  CA FD91             JP      Z,GOBACK1       ;not ready? Just return (directly).
 1658 F2E7  CD FE09             CALL    CONIN           ;yes, get character.
 1659 F2EA  C3 F301             JP      SETSTAT         ;set status and return.
 1660                   ;
 1661                   ;   Function to return the i/o byte.
 1662                   ;
 1663 F2ED  3A 0003     GETIOB: LD      A,(IOBYTE)
 1664 F2F0  C3 F301             JP      SETSTAT
 1665                   ;
 1666                   ;   Function to set the i/o byte.
 1667                   ;
 1668 F2F3  21 0003     SETIOB: LD      HL,IOBYTE
 1669 F2F6  71                  LD      (HL),C
 1670 F2F7  C9                  RET     
 1671                   ;
 1672                   ;   Function to print the character string pointed to by (DE)
 1673                   ; on the console device. The string ends with a '$'.
 1674                   ;
 1675 F2F8  EB          PRTSTR: EX      DE,HL
 1676 F2F9  4D                  LD      C,L
 1677 F2FA  44                  LD      B,H             ;now (BC) points to it.
 1678 F2FB  C3 F1D3             JP      PRTMESG
 1679                   ;
 1680                   ;   Function to interigate the console device.
 1681                   ;
 1682 F2FE  CD F123     GETCSTS:CALL    CKCONSOL
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  30
BDOS22  Z80

 1683                   ;
 1684                   ;   Get here to set the status and return to the cleanup
 1685                   ; section. Then back to the user.
 1686                   ;
 1687 F301  32 F345     SETSTAT:LD      (STATUS),A
 1688 F304  C9          RTN:    RET     
 1689                   ;
 1690                   ;   Set the status to 1 (read or write error code).
 1691                   ;
 1692 F305  3E 01       IOERR1: LD      A,1
 1693 F307  C3 F301             JP      SETSTAT
 1694                   ;
 1695 F30A  00          OUTFLAG: DB     0               ;output flag (non zero means no output).
 1696 F30B  02          STARTING:  DB   2               ;starting position for cursor.
 1697 F30C  00          CURPOS:  DB     0               ;cursor position (0=start of line).
 1698 F30D  00          PRTFLAG: DB     0               ;printer flag (control-p toggle). List if non zero.
 1699 F30E  00          CHARBUF: DB     0               ;single input character buffer.
 1700                   ;
 1701                   ;   Stack area for BDOS calls.
 1702                   ;
 1703 F30F  0000        USRSTACK:  DW   0               ;save users stack pointer here.
 1704                   ;
 1705 F311  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1706 F329  00 00 00 00          DB     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 1707         F341      STKAREA  EQU    $               ;end of stack area.
 1708                   ;
 1709 F341  00          USERNO:  DB     0               ;current user number.
 1710 F342  00          ACTIVE:  DB     0               ;currently active drive.
 1711 F343  0000        PARAMS:  DW     0               ;save (DE) parameters here on entry.
 1712 F345  0000        STATUS:  DW     0               ;status returned from bdos function.
 1713                   ;
 1714                   ;   Select error occured, jump to error routine.
 1715                   ;
 1716 F347  21 F00B     SLCTERR:LD      HL,BADSLCT
 1717                   ;
 1718                   ;   Jump to (HL) indirectly.
 1719                   ;
 1720 F34A  5E          JUMPHL: LD      E,(HL)
 1721 F34B  23                  INC     HL
 1722 F34C  56                  LD      D,(HL)          ;now (DE) contain the desired address.
 1723 F34D  EB                  EX      DE,HL
 1724 F34E  E9                  JP      (HL)
 1725                   ;
 1726                   ;   Block move. (DE) to (HL), (C) bytes total.
 1727                   ;
 1728 F34F  0C          DE2HL:  INC     C               ;is count down to zero?
 1729 F350  0D          DE2HL1: DEC     C
 1730 F351  C8                  RET     Z               ;yes, we are done.
 1731 F352  1A                  LD      A,(DE)          ;no, move one more byte.
 1732 F353  77                  LD      (HL),A
 1733 F354  13                  INC     DE
 1734 F355  23                  INC     HL
 1735 F356  C3 F350             JP      DE2HL1          ;and repeat.
 1736                   ;
 1737                   ;   Select the desired drive.
 1738                   ;
 1739 F359  3A F342     SELECT: LD      A,(ACTIVE)      ;get active disk.
 1740 F35C  4F                  LD      C,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  31
BDOS22  Z80

 1741 F35D  CD FE1B             CALL    SELDSK          ;select it.
 1742 F360  7C                  LD      A,H             ;valid drive?
 1743 F361  B5                  OR      L               ;valid drive?
 1744 F362  C8                  RET     Z               ;return if not.
 1745                   ;
 1746                   ;   Here, the BIOS returned the address of the parameter block
 1747                   ; in (HL). We will extract the necessary pointers and save them.
 1748                   ;
 1749 F363  5E                  LD      E,(HL)          ;yes, get address of translation table into (DE).
 1750 F364  23                  INC     HL
 1751 F365  56                  LD      D,(HL)
 1752 F366  23                  INC     HL
 1753 F367  22 FDB3             LD      (SCRATCH1),HL   ;save pointers to scratch areas.
 1754 F36A  23                  INC     HL
 1755 F36B  23                  INC     HL
 1756 F36C  22 FDB5             LD      (SCRATCH2),HL   ;ditto.
 1757 F36F  23                  INC     HL
 1758 F370  23                  INC     HL
 1759 F371  22 FDB7             LD      (SCRATCH3),HL   ;ditto.
 1760 F374  23                  INC     HL
 1761 F375  23                  INC     HL
 1762 F376  EB                  EX      DE,HL           ;now save the translation table address.
 1763 F377  22 FDD0             LD      (XLATE),HL
 1764 F37A  21 FDB9             LD      HL,DIRBUF       ;put the next 8 bytes here.
 1765 F37D  0E 08               LD      C,8             ;they consist of the directory buffer
 1766 F37F  CD F34F             CALL    DE2HL           ;pointer, parameter block pointer,
 1767 F382  2A FDBB             LD      HL,(DISKPB)     ;check and allocation vectors.
 1768 F385  EB                  EX      DE,HL
 1769 F386  21 FDC1             LD      HL,SECTORS      ;move parameter block into our ram.
 1770 F389  0E 0F               LD      C,15            ;it is 15 bytes long.
 1771 F38B  CD F34F             CALL    DE2HL
 1772 F38E  2A FDC6             LD      HL,(DSKSIZE)    ;check disk size.
 1773 F391  7C                  LD      A,H             ;more than 256 blocks on this?
 1774 F392  21 FDDD             LD      HL,BIGDISK
 1775 F395  36 FF               LD      (HL),0FFH       ;set to samll.
 1776 F397  B7                  OR      A
 1777 F398  CA F39D             JP      Z,SELECT1
 1778 F39B  36 00               LD      (HL),0          ;wrong, set to large.
 1779 F39D  3E FF       SELECT1:LD      A,0FFH          ;clear the zero flag.
 1780 F39F  B7                  OR      A
 1781 F3A0  C9                  RET     
 1782                   ;
 1783                   ;   Routine to home the disk track head and clear pointers.
 1784                   ;
 1785 F3A1  CD FE18     HOMEDRV:CALL    HOME            ;home the head.
 1786 F3A4  AF                  XOR     A
 1787 F3A5  2A FDB5             LD      HL,(SCRATCH2)   ;set our track pointer also.
 1788 F3A8  77                  LD      (HL),A
 1789 F3A9  23                  INC     HL
 1790 F3AA  77                  LD      (HL),A
 1791 F3AB  2A FDB7             LD      HL,(SCRATCH3)   ;and our sector pointer.
 1792 F3AE  77                  LD      (HL),A
 1793 F3AF  23                  INC     HL
 1794 F3B0  77                  LD      (HL),A
 1795 F3B1  C9                  RET     
 1796                   ;
 1797                   ;   Do the actual disk read and check the error return status.
 1798                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  32
BDOS22  Z80

 1799 F3B2  CD FE27     DOREAD: CALL    READ
 1800 F3B5  C3 F3BB             JP      IORET
 1801                   ;
 1802                   ;   Do the actual disk write and handle any bios error.
 1803                   ;
 1804 F3B8  CD FE2A     DOWRITE:CALL    WRITE
 1805 F3BB  B7          IORET:  OR      A
 1806 F3BC  C8                  RET     Z               ;return unless an error occured.
 1807 F3BD  21 F009             LD      HL,BADSCTR      ;bad read/write on this sector.
 1808 F3C0  C3 F34A             JP      JUMPHL
 1809                   ;
 1810                   ;   Routine to select the track and sector that the desired
 1811                   ; block number falls in.
 1812                   ;
 1813 F3C3  2A FDEA     TRKSEC: LD      HL,(FILEPOS)    ;get position of last accessed file
 1814 F3C6  0E 02               LD      C,2             ;in directory and compute sector #.
 1815 F3C8  CD F4EA             CALL    SHIFTR          ;sector #=file-position/4.
 1816 F3CB  22 FDE5             LD      (BLKNMBR),HL    ;save this as the block number of interest.
 1817 F3CE  22 FDEC             LD      (CKSUMTBL),HL   ;what's it doing here too?
 1818                   ;
 1819                   ;   if the sector number has already been set (BLKNMBR), enter
 1820                   ; at this point.
 1821                   ;
 1822 F3D1  21 FDE5     TRKSEC1:LD      HL,BLKNMBR
 1823 F3D4  4E                  LD      C,(HL)          ;move sector number into (BC).
 1824 F3D5  23                  INC     HL
 1825 F3D6  46                  LD      B,(HL)
 1826 F3D7  2A FDB7             LD      HL,(SCRATCH3)   ;get current sector number and
 1827 F3DA  5E                  LD      E,(HL)          ;move this into (DE).
 1828 F3DB  23                  INC     HL
 1829 F3DC  56                  LD      D,(HL)
 1830 F3DD  2A FDB5             LD      HL,(SCRATCH2)   ;get current track number.
 1831 F3E0  7E                  LD      A,(HL)          ;and this into (HL).
 1832 F3E1  23                  INC     HL
 1833 F3E2  66                  LD      H,(HL)
 1834 F3E3  6F                  LD      L,A
 1835 F3E4  79          TRKSEC2:LD      A,C             ;is desired sector before current one?
 1836 F3E5  93                  SUB     E
 1837 F3E6  78                  LD      A,B
 1838 F3E7  9A                  SBC     A,D
 1839 F3E8  D2 F3FA             JP      NC,TRKSEC3
 1840 F3EB  E5                  PUSH    HL              ;yes, decrement sectors by one track.
 1841 F3EC  2A FDC1             LD      HL,(SECTORS)    ;get sectors per track.
 1842 F3EF  7B                  LD      A,E
 1843 F3F0  95                  SUB     L
 1844 F3F1  5F                  LD      E,A
 1845 F3F2  7A                  LD      A,D
 1846 F3F3  9C                  SBC     A,H
 1847 F3F4  57                  LD      D,A             ;now we have backed up one full track.
 1848 F3F5  E1                  POP     HL
 1849 F3F6  2B                  DEC     HL              ;adjust track counter.
 1850 F3F7  C3 F3E4             JP      TRKSEC2
 1851 F3FA  E5          TRKSEC3:PUSH    HL              ;desired sector is after current one.
 1852 F3FB  2A FDC1             LD      HL,(SECTORS)    ;get sectors per track.
 1853 F3FE  19                  ADD     HL,DE           ;bump sector pointer to next track.
 1854 F3FF  DA F40F             JP      C,TRKSEC4
 1855 F402  79                  LD      A,C             ;is desired sector now before current one?
 1856 F403  95                  SUB     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  33
BDOS22  Z80

 1857 F404  78                  LD      A,B
 1858 F405  9C                  SBC     A,H
 1859 F406  DA F40F             JP      C,TRKSEC4
 1860 F409  EB                  EX      DE,HL           ;not yes, increment track counter
 1861 F40A  E1                  POP     HL              ;and continue until it is.
 1862 F40B  23                  INC     HL
 1863 F40C  C3 F3FA             JP      TRKSEC3
 1864                   ;
 1865                   ;   here we have determined the track number that contains the
 1866                   ; desired sector.
 1867                   ;
 1868 F40F  E1          TRKSEC4:POP     HL              ;get track number (HL).
 1869 F410  C5                  PUSH    BC
 1870 F411  D5                  PUSH    DE
 1871 F412  E5                  PUSH    HL
 1872 F413  EB                  EX      DE,HL
 1873 F414  2A FDCE             LD      HL,(OFFSET)     ;adjust for first track offset.
 1874 F417  19                  ADD     HL,DE
 1875 F418  44                  LD      B,H
 1876 F419  4D                  LD      C,L
 1877 F41A  CD FE1E             CALL    SETTRK          ;select this track.
 1878 F41D  D1                  POP     DE              ;reset current track pointer.
 1879 F41E  2A FDB5             LD      HL,(SCRATCH2)
 1880 F421  73                  LD      (HL),E
 1881 F422  23                  INC     HL
 1882 F423  72                  LD      (HL),D
 1883 F424  D1                  POP     DE
 1884 F425  2A FDB7             LD      HL,(SCRATCH3)   ;reset the first sector on this track.
 1885 F428  73                  LD      (HL),E
 1886 F429  23                  INC     HL
 1887 F42A  72                  LD      (HL),D
 1888 F42B  C1                  POP     BC
 1889 F42C  79                  LD      A,C             ;now subtract the desired one.
 1890 F42D  93                  SUB     E               ;to make it relative (1-# sectors/track).
 1891 F42E  4F                  LD      C,A
 1892 F42F  78                  LD      A,B
 1893 F430  9A                  SBC     A,D
 1894 F431  47                  LD      B,A
 1895 F432  2A FDD0             LD      HL,(XLATE)      ;translate this sector according to this table.
 1896 F435  EB                  EX      DE,HL
 1897 F436  CD FE30             CALL    SECTRN          ;let the bios translate it.
 1898 F439  4D                  LD      C,L
 1899 F43A  44                  LD      B,H
 1900 F43B  C3 FE21             JP      SETSEC          ;and select it.
 1901                   ;
 1902                   ;   Compute block number from record number (SAVNREC) and
 1903                   ; extent number (SAVEXT).
 1904                   ;
 1905 F43E  21 FDC3     GETBLOCK: LD    HL,BLKSHFT      ;get logical to physical conversion.
 1906 F441  4E                  LD      C,(HL)          ;note that this is base 2 log of ratio.
 1907 F442  3A FDE3             LD      A,(SAVNREC)     ;get record number.
 1908 F445  B7          GETBLK1:OR      A               ;compute (A)=(A)/2^BLKSHFT.
 1909 F446  1F                  RRA     
 1910 F447  0D                  DEC     C
 1911 F448  C2 F445             JP      NZ,GETBLK1
 1912 F44B  47                  LD      B,A             ;save result in (B).
 1913 F44C  3E 08               LD      A,8
 1914 F44E  96                  SUB     (HL)
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  34
BDOS22  Z80

 1915 F44F  4F                  LD      C,A             ;compute (C)=8-BLKSHFT.
 1916 F450  3A FDE2             LD      A,(SAVEXT)
 1917 F453  0D          GETBLK2:DEC     C               ;compute (A)=SAVEXT*2^(8-BLKSHFT).
 1918 F454  CA F45C             JP      Z,GETBLK3
 1919 F457  B7                  OR      A
 1920 F458  17                  RLA     
 1921 F459  C3 F453             JP      GETBLK2
 1922 F45C  80          GETBLK3:ADD     A,B
 1923 F45D  C9                  RET     
 1924                   ;
 1925                   ;   Routine to extract the (BC) block byte from the fcb pointed
 1926                   ; to by (PARAMS). If this is a big-disk, then these are 16 bit
 1927                   ; block numbers, else they are 8 bit numbers.
 1928                   ; Number is returned in (HL).
 1929                   ;
 1930 F45E  2A F343     EXTBLK: LD      HL,(PARAMS)     ;get fcb address.
 1931 F461  11 0010             LD      DE,16           ;block numbers start 16 bytes into fcb.
 1932 F464  19                  ADD     HL,DE
 1933 F465  09                  ADD     HL,BC
 1934 F466  3A FDDD             LD      A,(BIGDISK)     ;are we using a big-disk?
 1935 F469  B7                  OR      A
 1936 F46A  CA F471             JP      Z,EXTBLK1
 1937 F46D  6E                  LD      L,(HL)          ;no, extract an 8 bit number from the fcb.
 1938 F46E  26 00               LD      H,0
 1939 F470  C9                  RET     
 1940 F471  09          EXTBLK1:ADD     HL,BC           ;yes, extract a 16 bit number.
 1941 F472  5E                  LD      E,(HL)
 1942 F473  23                  INC     HL
 1943 F474  56                  LD      D,(HL)
 1944 F475  EB                  EX      DE,HL           ;return in (HL).
 1945 F476  C9                  RET     
 1946                   ;
 1947                   ;   Compute block number.
 1948                   ;
 1949 F477  CD F43E     COMBLK: CALL    GETBLOCK
 1950 F47A  4F                  LD      C,A
 1951 F47B  06 00               LD      B,0
 1952 F47D  CD F45E             CALL    EXTBLK
 1953 F480  22 FDE5             LD      (BLKNMBR),HL
 1954 F483  C9                  RET     
 1955                   ;
 1956                   ;   Check for a zero block number (unused).
 1957                   ;
 1958 F484  2A FDE5     CHKBLK: LD      HL,(BLKNMBR)
 1959 F487  7D                  LD      A,L             ;is it zero?
 1960 F488  B4                  OR      H
 1961 F489  C9                  RET     
 1962                   ;
 1963                   ;   Adjust physical block (BLKNMBR) and convert to logical
 1964                   ; sector (LOGSECT). This is the starting sector of this block.
 1965                   ; The actual sector of interest is then added to this and the
 1966                   ; resulting sector number is stored back in (BLKNMBR). This
 1967                   ; will still have to be adjusted for the track number.
 1968                   ;
 1969 F48A  3A FDC3     LOGICAL:LD      A,(BLKSHFT)     ;get log2(physical/logical sectors).
 1970 F48D  2A FDE5             LD      HL,(BLKNMBR)    ;get physical sector desired.
 1971 F490  29          LOGICL1:ADD     HL,HL           ;compute logical sector number.
 1972 F491  3D                  DEC     A               ;note logical sectors are 128 bytes long.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  35
BDOS22  Z80

 1973 F492  C2 F490             JP      NZ,LOGICL1
 1974 F495  22 FDE7             LD      (LOGSECT),HL    ;save logical sector.
 1975 F498  3A FDC4             LD      A,(BLKMASK)     ;get block mask.
 1976 F49B  4F                  LD      C,A
 1977 F49C  3A FDE3             LD      A,(SAVNREC)     ;get next sector to access.
 1978 F49F  A1                  AND     C               ;extract the relative position within physical block.
 1979 F4A0  B5                  OR      L               ;and add it too logical sector.
 1980 F4A1  6F                  LD      L,A
 1981 F4A2  22 FDE5             LD      (BLKNMBR),HL    ;and store.
 1982 F4A5  C9                  RET     
 1983                   ;
 1984                   ;   Set (HL) to point to extent byte in fcb.
 1985                   ;
 1986 F4A6  2A F343     SETEXT: LD      HL,(PARAMS)
 1987 F4A9  11 000C             LD      DE,12           ;it is the twelth byte.
 1988 F4AC  19                  ADD     HL,DE
 1989 F4AD  C9                  RET     
 1990                   ;
 1991                   ;   Set (HL) to point to record count byte in fcb and (DE) to
 1992                   ; next record number byte.
 1993                   ;
 1994 F4AE  2A F343     SETHLDE:LD      HL,(PARAMS)
 1995 F4B1  11 000F             LD      DE,15           ;record count byte (#15).
 1996 F4B4  19                  ADD     HL,DE
 1997 F4B5  EB                  EX      DE,HL
 1998 F4B6  21 0011             LD      HL,17           ;next record number (#32).
 1999 F4B9  19                  ADD     HL,DE
 2000 F4BA  C9                  RET     
 2001                   ;
 2002                   ;   Save current file data from fcb.
 2003                   ;
 2004 F4BB  CD F4AE     STRDATA:CALL    SETHLDE
 2005 F4BE  7E                  LD      A,(HL)          ;get and store record count byte.
 2006 F4BF  32 FDE3             LD      (SAVNREC),A
 2007 F4C2  EB                  EX      DE,HL
 2008 F4C3  7E                  LD      A,(HL)          ;get and store next record number byte.
 2009 F4C4  32 FDE1             LD      (SAVNXT),A
 2010 F4C7  CD F4A6             CALL    SETEXT          ;point to extent byte.
 2011 F4CA  3A FDC5             LD      A,(EXTMASK)     ;get extent mask.
 2012 F4CD  A6                  AND     (HL)
 2013 F4CE  32 FDE2             LD      (SAVEXT),A      ;and save extent here.
 2014 F4D1  C9                  RET     
 2015                   ;
 2016                   ;   Set the next record to access. If (MODE) is set to 2, then
 2017                   ; the last record byte (SAVNREC) has the correct number to access.
 2018                   ; For sequential access, (MODE) will be equal to 1.
 2019                   ;
 2020 F4D2  CD F4AE     SETNREC:CALL    SETHLDE
 2021 F4D5  3A FDD5             LD      A,(MODE)        ;get sequential flag (=1).
 2022 F4D8  FE 02               CP      2               ;a 2 indicates that no adder is needed.
 2023 F4DA  C2 F4DE             JP      NZ,STNREC1
 2024 F4DD  AF                  XOR     A               ;clear adder (random access?).
 2025 F4DE  4F          STNREC1:LD      C,A
 2026 F4DF  3A FDE3             LD      A,(SAVNREC)     ;get last record number.
 2027 F4E2  81                  ADD     A,C             ;increment record count.
 2028 F4E3  77                  LD      (HL),A          ;and set fcb's next record byte.
 2029 F4E4  EB                  EX      DE,HL
 2030 F4E5  3A FDE1             LD      A,(SAVNXT)      ;get next record byte from storage.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  36
BDOS22  Z80

 2031 F4E8  77                  LD      (HL),A          ;and put this into fcb as number of records used.
 2032 F4E9  C9                  RET     
 2033                   ;
 2034                   ;   Shift (HL) right (C) bits.
 2035                   ;
 2036 F4EA  0C          SHIFTR: INC     C
 2037 F4EB  0D          SHIFTR1:DEC     C
 2038 F4EC  C8                  RET     Z
 2039 F4ED  7C                  LD      A,H
 2040 F4EE  B7                  OR      A
 2041 F4EF  1F                  RRA     
 2042 F4F0  67                  LD      H,A
 2043 F4F1  7D                  LD      A,L
 2044 F4F2  1F                  RRA     
 2045 F4F3  6F                  LD      L,A
 2046 F4F4  C3 F4EB             JP      SHIFTR1
 2047                   ;
 2048                   ;   Compute the check-sum for the directory buffer. Return
 2049                   ; integer sum in (A).
 2050                   ;
 2051 F4F7  0E 80       CHECKSUM: LD    C,128           ;length of buffer.
 2052 F4F9  2A FDB9             LD      HL,(DIRBUF)     ;get its location.
 2053 F4FC  AF                  XOR     A               ;clear summation byte.
 2054 F4FD  86          CHKSUM1:ADD     A,(HL)          ;and compute sum ignoring carries.
 2055 F4FE  23                  INC     HL
 2056 F4FF  0D                  DEC     C
 2057 F500  C2 F4FD             JP      NZ,CHKSUM1
 2058 F503  C9                  RET     
 2059                   ;
 2060                   ;   Shift (HL) left (C) bits.
 2061                   ;
 2062 F504  0C          SHIFTL: INC     C
 2063 F505  0D          SHIFTL1:DEC     C
 2064 F506  C8                  RET     Z
 2065 F507  29                  ADD     HL,HL           ;shift left 1 bit.
 2066 F508  C3 F505             JP      SHIFTL1
 2067                   ;
 2068                   ;   Routine to set a bit in a 16 bit value contained in (BC).
 2069                   ; The bit set depends on the current drive selection.
 2070                   ;
 2071 F50B  C5          SETBIT: PUSH    BC              ;save 16 bit word.
 2072 F50C  3A F342             LD      A,(ACTIVE)      ;get active drive.
 2073 F50F  4F                  LD      C,A
 2074 F510  21 0001             LD      HL,1
 2075 F513  CD F504             CALL    SHIFTL          ;shift bit 0 into place.
 2076 F516  C1                  POP     BC              ;now 'or' this with the original word.
 2077 F517  79                  LD      A,C
 2078 F518  B5                  OR      L
 2079 F519  6F                  LD      L,A             ;low byte done, do high byte.
 2080 F51A  78                  LD      A,B
 2081 F51B  B4                  OR      H
 2082 F51C  67                  LD      H,A
 2083 F51D  C9                  RET     
 2084                   ;
 2085                   ;   Extract the write protect status bit for the current drive.
 2086                   ; The result is returned in (A), bit 0.
 2087                   ;
 2088 F51E  2A FDAD     GETWPRT:LD      HL,(WRTPRT)     ;get status bytes.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  37
BDOS22  Z80

 2089 F521  3A F342             LD      A,(ACTIVE)      ;which drive is current?
 2090 F524  4F                  LD      C,A
 2091 F525  CD F4EA             CALL    SHIFTR          ;shift status such that bit 0 is the
 2092 F528  7D                  LD      A,L             ;one of interest for this drive.
 2093 F529  E6 01               AND     01H             ;and isolate it.
 2094 F52B  C9                  RET     
 2095                   ;
 2096                   ;   Function to write protect the current disk.
 2097                   ;
 2098 F52C  21 FDAD     WRTPRTD:LD      HL,WRTPRT       ;point to status word.
 2099 F52F  4E                  LD      C,(HL)          ;set (BC) equal to the status.
 2100 F530  23                  INC     HL
 2101 F531  46                  LD      B,(HL)
 2102 F532  CD F50B             CALL    SETBIT          ;and set this bit according to current drive.
 2103 F535  22 FDAD             LD      (WRTPRT),HL     ;then save.
 2104 F538  2A FDC8             LD      HL,(DIRSIZE)    ;now save directory size limit.
 2105 F53B  23                  INC     HL              ;remember the last one.
 2106 F53C  EB                  EX      DE,HL
 2107 F53D  2A FDB3             LD      HL,(SCRATCH1)   ;and store it here.
 2108 F540  73                  LD      (HL),E          ;put low byte.
 2109 F541  23                  INC     HL
 2110 F542  72                  LD      (HL),D          ;then high byte.
 2111 F543  C9                  RET     
 2112                   ;
 2113                   ;   Check for a read only file.
 2114                   ;
 2115 F544  CD F55E     CHKROFL:CALL    FCB2HL          ;set (HL) to file entry in directory buffer.
 2116 F547  11 0009     CKROF1: LD      DE,9            ;look at bit 7 of the ninth byte.
 2117 F54A  19                  ADD     HL,DE
 2118 F54B  7E                  LD      A,(HL)
 2119 F54C  17                  RLA     
 2120 F54D  D0                  RET     NC              ;return if ok.
 2121 F54E  21 F00F             LD      HL,ROFILE       ;else, print error message and terminate.
 2122 F551  C3 F34A             JP      JUMPHL
 2123                   ;
 2124                   ;   Check the write protect status of the active disk.
 2125                   ;
 2126 F554  CD F51E     CHKWPRT:CALL    GETWPRT
 2127 F557  C8                  RET     Z               ;return if ok.
 2128 F558  21 F00D             LD      HL,RODISK       ;else print message and terminate.
 2129 F55B  C3 F34A             JP      JUMPHL
 2130                   ;
 2131                   ;   Routine to set (HL) pointing to the proper entry in the
 2132                   ; directory buffer.
 2133                   ;
 2134 F55E  2A FDB9     FCB2HL: LD      HL,(DIRBUF)     ;get address of buffer.
 2135 F561  3A FDE9             LD      A,(FCBPOS)      ;relative position of file.
 2136                   ;
 2137                   ;   Routine to add (A) to (HL).
 2138                   ;
 2139 F564  85          ADDA2HL:ADD     A,L
 2140 F565  6F                  LD      L,A
 2141 F566  D0                  RET     NC
 2142 F567  24                  INC     H               ;take care of any carry.
 2143 F568  C9                  RET     
 2144                   ;
 2145                   ;   Routine to get the 's2' byte from the fcb supplied in
 2146                   ; the initial parameter specification.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  38
BDOS22  Z80

 2147                   ;
 2148 F569  2A F343     GETS2:  LD      HL,(PARAMS)     ;get address of fcb.
 2149 F56C  11 000E             LD      DE,14           ;relative position of 's2'.
 2150 F56F  19                  ADD     HL,DE
 2151 F570  7E                  LD      A,(HL)          ;extract this byte.
 2152 F571  C9                  RET     
 2153                   ;
 2154                   ;   Clear the 's2' byte in the fcb.
 2155                   ;
 2156 F572  CD F569     CLEARS2:CALL    GETS2           ;this sets (HL) pointing to it.
 2157 F575  36 00               LD      (HL),0          ;now clear it.
 2158 F577  C9                  RET     
 2159                   ;
 2160                   ;   Set bit 7 in the 's2' byte of the fcb.
 2161                   ;
 2162 F578  CD F569     SETS2B7:CALL    GETS2           ;get the byte.
 2163 F57B  F6 80               OR      80H             ;and set bit 7.
 2164 F57D  77                  LD      (HL),A          ;then store.
 2165 F57E  C9                  RET     
 2166                   ;
 2167                   ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
 2168                   ; the difference. This checks to see if there are more file
 2169                   ; names in the directory. We are at (FILEPOS) and there are
 2170                   ; (SCRATCH1) of them to check.
 2171                   ;
 2172 F57F  2A FDEA     MOREFLS:LD      HL,(FILEPOS)    ;we are here.
 2173 F582  EB                  EX      DE,HL
 2174 F583  2A FDB3             LD      HL,(SCRATCH1)   ;and don't go past here.
 2175 F586  7B                  LD      A,E             ;compute difference but don't keep.
 2176 F587  96                  SUB     (HL)
 2177 F588  23                  INC     HL
 2178 F589  7A                  LD      A,D
 2179 F58A  9E                  SBC     A,(HL)          ;set carry if no more names.
 2180 F58B  C9                  RET     
 2181                   ;
 2182                   ;   Call this routine to prevent (SCRATCH1) from being greater
 2183                   ; than (FILEPOS).
 2184                   ;
 2185 F58C  CD F57F     CHKNMBR:CALL    MOREFLS         ;SCRATCH1 too big?
 2186 F58F  D8                  RET     C
 2187 F590  13                  INC     DE              ;yes, reset it to (FILEPOS).
 2188 F591  72                  LD      (HL),D
 2189 F592  2B                  DEC     HL
 2190 F593  73                  LD      (HL),E
 2191 F594  C9                  RET     
 2192                   ;
 2193                   ;   Compute (HL)=(DE)-(HL)
 2194                   ;
 2195 F595  7B          SUBHL:  LD      A,E             ;compute difference.
 2196 F596  95                  SUB     L
 2197 F597  6F                  LD      L,A             ;store low byte.
 2198 F598  7A                  LD      A,D
 2199 F599  9C                  SBC     A,H
 2200 F59A  67                  LD      H,A             ;and then high byte.
 2201 F59B  C9                  RET     
 2202                   ;
 2203                   ;   Set the directory checksum byte.
 2204                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  39
BDOS22  Z80

 2205 F59C  0E FF       SETDIR: LD      C,0FFH
 2206                   ;
 2207                   ;   Routine to set or compare the directory checksum byte. If
 2208                   ; (C)=0ffh, then this will set the checksum byte. Else the byte
 2209                   ; will be checked. If the check fails (the disk has been changed),
 2210                   ; then this disk will be write protected.
 2211                   ;
 2212 F59E  2A FDEC     CHECKDIR: LD    HL,(CKSUMTBL)
 2213 F5A1  EB                  EX      DE,HL
 2214 F5A2  2A FDCC             LD      HL,(ALLOC1)
 2215 F5A5  CD F595             CALL    SUBHL
 2216 F5A8  D0                  RET     NC              ;ok if (CKSUMTBL) > (ALLOC1), so return.
 2217 F5A9  C5                  PUSH    BC
 2218 F5AA  CD F4F7             CALL    CHECKSUM        ;else compute checksum.
 2219 F5AD  2A FDBD             LD      HL,(CHKVECT)    ;get address of checksum table.
 2220 F5B0  EB                  EX      DE,HL
 2221 F5B1  2A FDEC             LD      HL,(CKSUMTBL)
 2222 F5B4  19                  ADD     HL,DE           ;set (HL) to point to byte for this drive.
 2223 F5B5  C1                  POP     BC
 2224 F5B6  0C                  INC     C               ;set or check ?
 2225 F5B7  CA F5C4             JP      Z,CHKDIR1
 2226 F5BA  BE                  CP      (HL)            ;check them.
 2227 F5BB  C8                  RET     Z               ;return if they are the same.
 2228 F5BC  CD F57F             CALL    MOREFLS         ;not the same, do we care?
 2229 F5BF  D0                  RET     NC
 2230 F5C0  CD F52C             CALL    WRTPRTD         ;yes, mark this as write protected.
 2231 F5C3  C9                  RET     
 2232 F5C4  77          CHKDIR1:LD      (HL),A          ;just set the byte.
 2233 F5C5  C9                  RET     
 2234                   ;
 2235                   ;   Do a write to the directory of the current disk.
 2236                   ;
 2237 F5C6  CD F59C     DIRWRITE: CALL  SETDIR          ;set checksum byte.
 2238 F5C9  CD F5E0             CALL    DIRDMA          ;set directory dma address.
 2239 F5CC  0E 01               LD      C,1             ;tell the bios to actually write.
 2240 F5CE  CD F3B8             CALL    DOWRITE         ;then do the write.
 2241 F5D1  C3 F5DA             JP      DEFDMA
 2242                   ;
 2243                   ;   Read from the directory.
 2244                   ;
 2245 F5D4  CD F5E0     DIRREAD:CALL    DIRDMA          ;set the directory dma address.
 2246 F5D7  CD F3B2             CALL    DOREAD          ;and read it.
 2247                   ;
 2248                   ;   Routine to set the dma address to the users choice.
 2249                   ;
 2250 F5DA  21 FDB1     DEFDMA: LD      HL,USERDMA      ;reset the default dma address and return.
 2251 F5DD  C3 F5E3             JP      DIRDMA1
 2252                   ;
 2253                   ;   Routine to set the dma address for directory work.
 2254                   ;
 2255 F5E0  21 FDB9     DIRDMA: LD      HL,DIRBUF
 2256                   ;
 2257                   ;   Set the dma address. On entry, (HL) points to
 2258                   ; word containing the desired dma address.
 2259                   ;
 2260 F5E3  4E          DIRDMA1:LD      C,(HL)
 2261 F5E4  23                  INC     HL
 2262 F5E5  46                  LD      B,(HL)          ;setup (BC) and go to the bios to set it.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  40
BDOS22  Z80

 2263 F5E6  C3 FE24             JP      SETDMA
 2264                   ;
 2265                   ;   Move the directory buffer into user's dma space.
 2266                   ;
 2267 F5E9  2A FDB9     MOVEDIR:LD      HL,(DIRBUF)     ;buffer is located here, and
 2268 F5EC  EB                  EX      DE,HL
 2269 F5ED  2A FDB1             LD      HL,(USERDMA)    ; put it here.
 2270 F5F0  0E 80               LD      C,128           ;this is its length.
 2271 F5F2  C3 F34F             JP      DE2HL           ;move it now and return.
 2272                   ;
 2273                   ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
 2274                   ;
 2275 F5F5  21 FDEA     CKFILPOS: LD    HL,FILEPOS
 2276 F5F8  7E                  LD      A,(HL)
 2277 F5F9  23                  INC     HL
 2278 F5FA  BE                  CP      (HL)            ;are both bytes the same?
 2279 F5FB  C0                  RET     NZ
 2280 F5FC  3C                  INC     A               ;yes, but are they each 0ffh?
 2281 F5FD  C9                  RET     
 2282                   ;
 2283                   ;   Set location (FILEPOS) to 0ffffh.
 2284                   ;
 2285 F5FE  21 FFFF     STFILPOS: LD    HL,0FFFFH
 2286 F601  22 FDEA             LD      (FILEPOS),HL
 2287 F604  C9                  RET     
 2288                   ;
 2289                   ;   Move on to the next file position within the current
 2290                   ; directory buffer. If no more exist, set pointer to 0ffffh
 2291                   ; and the calling routine will check for this. Enter with (C)
 2292                   ; equal to 0ffh to cause the checksum byte to be set, else we
 2293                   ; will check this disk and set write protect if checksums are
 2294                   ; not the same (applies only if another directory sector must
 2295                   ; be read).
 2296                   ;
 2297 F605  2A FDC8     NXENTRY:LD      HL,(DIRSIZE)    ;get directory entry size limit.
 2298 F608  EB                  EX      DE,HL
 2299 F609  2A FDEA             LD      HL,(FILEPOS)    ;get current count.
 2300 F60C  23                  INC     HL              ;go on to the next one.
 2301 F60D  22 FDEA             LD      (FILEPOS),HL
 2302 F610  CD F595             CALL    SUBHL           ;(HL)=(DIRSIZE)-(FILEPOS)
 2303 F613  D2 F619             JP      NC,NXENT1       ;is there more room left?
 2304 F616  C3 F5FE             JP      STFILPOS        ;no. Set this flag and return.
 2305 F619  3A FDEA     NXENT1: LD      A,(FILEPOS)     ;get file position within directory.
 2306 F61C  E6 03               AND     03H             ;only look within this sector (only 4 entries fit).
 2307 F61E  06 05               LD      B,5             ;convert to relative position (32 bytes each).
 2308 F620  87          NXENT2: ADD     A,A             ;note that this is not efficient code.
 2309 F621  05                  DEC     B               ;5 'ADD A's would be better.
 2310 F622  C2 F620             JP      NZ,NXENT2
 2311 F625  32 FDE9             LD      (FCBPOS),A      ;save it as position of fcb.
 2312 F628  B7                  OR      A
 2313 F629  C0                  RET     NZ              ;return if we are within buffer.
 2314 F62A  C5                  PUSH    BC
 2315 F62B  CD F3C3             CALL    TRKSEC          ;we need the next directory sector.
 2316 F62E  CD F5D4             CALL    DIRREAD
 2317 F631  C1                  POP     BC
 2318 F632  C3 F59E             JP      CHECKDIR
 2319                   ;
 2320                   ;   Routine to to get a bit from the disk space allocation
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  41
BDOS22  Z80

 2321                   ; map. It is returned in (A), bit position 0. On entry to here,
 2322                   ; set (BC) to the block number on the disk to check.
 2323                   ; On return, (D) will contain the original bit position for
 2324                   ; this block number and (HL) will point to the address for it.
 2325                   ;
 2326 F635  79          CKBITMAP: LD    A,C             ;determine bit number of interest.
 2327 F636  E6 07               AND     07H             ;compute (D)=(E)=(C and 7)+1.
 2328 F638  3C                  INC     A
 2329 F639  5F                  LD      E,A             ;save particular bit number.
 2330 F63A  57                  LD      D,A
 2331                   ;
 2332                   ;   compute (BC)=(BC)/8.
 2333                   ;
 2334 F63B  79                  LD      A,C
 2335 F63C  0F                  RRCA                    ;now shift right 3 bits.
 2336 F63D  0F                  RRCA    
 2337 F63E  0F                  RRCA    
 2338 F63F  E6 1F               AND     1FH             ;and clear bits 7,6,5.
 2339 F641  4F                  LD      C,A
 2340 F642  78                  LD      A,B
 2341 F643  87                  ADD     A,A             ;now shift (B) into bits 7,6,5.
 2342 F644  87                  ADD     A,A
 2343 F645  87                  ADD     A,A
 2344 F646  87                  ADD     A,A
 2345 F647  87                  ADD     A,A
 2346 F648  B1                  OR      C               ;and add in (C).
 2347 F649  4F                  LD      C,A             ;ok, (C) ha been completed.
 2348 F64A  78                  LD      A,B             ;is there a better way of doing this?
 2349 F64B  0F                  RRCA    
 2350 F64C  0F                  RRCA    
 2351 F64D  0F                  RRCA    
 2352 F64E  E6 1F               AND     1FH
 2353 F650  47                  LD      B,A             ;and now (B) is completed.
 2354                   ;
 2355                   ;   use this as an offset into the disk space allocation
 2356                   ; table.
 2357                   ;
 2358 F651  2A FDBF             LD      HL,(ALOCVECT)
 2359 F654  09                  ADD     HL,BC
 2360 F655  7E                  LD      A,(HL)          ;now get correct byte.
 2361 F656  07          CKBMAP1:RLCA                    ;get correct bit into position 0.
 2362 F657  1D                  DEC     E
 2363 F658  C2 F656             JP      NZ,CKBMAP1
 2364 F65B  C9                  RET     
 2365                   ;
 2366                   ;   Set or clear the bit map such that block number (BC) will be marked
 2367                   ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
 2368                   ; 1 then it will be set (don't use anyother values).
 2369                   ;
 2370 F65C  D5          STBITMAP: PUSH  DE
 2371 F65D  CD F635             CALL    CKBITMAP        ;get the byte of interest.
 2372 F660  E6 FE               AND     0FEH            ;clear the affected bit.
 2373 F662  C1                  POP     BC
 2374 F663  B1                  OR      C               ;and now set it acording to (C).
 2375                   ;
 2376                   ;  entry to restore the original bit position and then store
 2377                   ; in table. (A) contains the value, (D) contains the bit
 2378                   ; position (1-8), and (HL) points to the address within the
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  42
BDOS22  Z80

 2379                   ; space allocation table for this byte.
 2380                   ;
 2381 F664  0F          STBMAP1:RRCA                    ;restore original bit position.
 2382 F665  15                  DEC     D
 2383 F666  C2 F664             JP      NZ,STBMAP1
 2384 F669  77                  LD      (HL),A          ;and stor byte in table.
 2385 F66A  C9                  RET     
 2386                   ;
 2387                   ;   Set/clear space used bits in allocation map for this file.
 2388                   ; On entry, (C)=1 to set the map and (C)=0 to clear it.
 2389                   ;
 2390 F66B  CD F55E     SETFILE:CALL    FCB2HL          ;get address of fcb
 2391 F66E  11 0010             LD      DE,16
 2392 F671  19                  ADD     HL,DE           ;get to block number bytes.
 2393 F672  C5                  PUSH    BC
 2394 F673  0E 11               LD      C,17            ;check all 17 bytes (max) of table.
 2395 F675  D1          SETFL1: POP     DE
 2396 F676  0D                  DEC     C               ;done all bytes yet?
 2397 F677  C8                  RET     Z
 2398 F678  D5                  PUSH    DE
 2399 F679  3A FDDD             LD      A,(BIGDISK)     ;check disk size for 16 bit block numbers.
 2400 F67C  B7                  OR      A
 2401 F67D  CA F688             JP      Z,SETFL2
 2402 F680  C5                  PUSH    BC              ;only 8 bit numbers. set (BC) to this one.
 2403 F681  E5                  PUSH    HL
 2404 F682  4E                  LD      C,(HL)          ;get low byte from table, always
 2405 F683  06 00               LD      B,0             ;set high byte to zero.
 2406 F685  C3 F68E             JP      SETFL3
 2407 F688  0D          SETFL2: DEC     C               ;for 16 bit block numbers, adjust counter.
 2408 F689  C5                  PUSH    BC
 2409 F68A  4E                  LD      C,(HL)          ;now get both the low and high bytes.
 2410 F68B  23                  INC     HL
 2411 F68C  46                  LD      B,(HL)
 2412 F68D  E5                  PUSH    HL
 2413 F68E  79          SETFL3: LD      A,C             ;block used?
 2414 F68F  B0                  OR      B
 2415 F690  CA F69D             JP      Z,SETFL4
 2416 F693  2A FDC6             LD      HL,(DSKSIZE)    ;is this block number within the
 2417 F696  7D                  LD      A,L             ;space on the disk?
 2418 F697  91                  SUB     C
 2419 F698  7C                  LD      A,H
 2420 F699  98                  SBC     A,B
 2421 F69A  D4 F65C             CALL    NC,STBITMAP     ;yes, set the proper bit.
 2422 F69D  E1          SETFL4: POP     HL              ;point to next block number in fcb.
 2423 F69E  23                  INC     HL
 2424 F69F  C1                  POP     BC
 2425 F6A0  C3 F675             JP      SETFL1
 2426                   ;
 2427                   ;   Construct the space used allocation bit map for the active
 2428                   ; drive. If a file name starts with '$' and it is under the
 2429                   ; current user number, then (STATUS) is set to minus 1. Otherwise
 2430                   ; it is not set at all.
 2431                   ;
 2432 F6A3  2A FDC6     BITMAP: LD      HL,(DSKSIZE)    ;compute size of allocation table.
 2433 F6A6  0E 03               LD      C,3
 2434 F6A8  CD F4EA             CALL    SHIFTR          ;(HL)=(HL)/8.
 2435 F6AB  23                  INC     HL              ;at lease 1 byte.
 2436 F6AC  44                  LD      B,H
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  43
BDOS22  Z80

 2437 F6AD  4D                  LD      C,L             ;set (BC) to the allocation table length.
 2438                   ;
 2439                   ;   Initialize the bitmap for this drive. Right now, the first
 2440                   ; two bytes are specified by the disk parameter block. However
 2441                   ; a patch could be entered here if it were necessary to setup
 2442                   ; this table in a special mannor. For example, the bios could
 2443                   ; determine locations of 'bad blocks' and set them as already
 2444                   ; 'used' in the map.
 2445                   ;
 2446 F6AE  2A FDBF             LD      HL,(ALOCVECT)   ;now zero out the table now.
 2447 F6B1  36 00       BITMAP1:LD      (HL),0
 2448 F6B3  23                  INC     HL
 2449 F6B4  0B                  DEC     BC
 2450 F6B5  78                  LD      A,B
 2451 F6B6  B1                  OR      C
 2452 F6B7  C2 F6B1             JP      NZ,BITMAP1
 2453 F6BA  2A FDCA             LD      HL,(ALLOC0)     ;get initial space used by directory.
 2454 F6BD  EB                  EX      DE,HL
 2455 F6BE  2A FDBF             LD      HL,(ALOCVECT)   ;and put this into map.
 2456 F6C1  73                  LD      (HL),E
 2457 F6C2  23                  INC     HL
 2458 F6C3  72                  LD      (HL),D
 2459                   ;
 2460                   ;   End of initialization portion.
 2461                   ;
 2462 F6C4  CD F3A1             CALL    HOMEDRV         ;now home the drive.
 2463 F6C7  2A FDB3             LD      HL,(SCRATCH1)
 2464 F6CA  36 03               LD      (HL),3          ;force next directory request to read
 2465 F6CC  23                  INC     HL              ;in a sector.
 2466 F6CD  36 00               LD      (HL),0
 2467 F6CF  CD F5FE             CALL    STFILPOS        ;clear initial file position also.
 2468 F6D2  0E FF       BITMAP2:LD      C,0FFH          ;read next file name in directory
 2469 F6D4  CD F605             CALL    NXENTRY         ;and set checksum byte.
 2470 F6D7  CD F5F5             CALL    CKFILPOS        ;is there another file?
 2471 F6DA  C8                  RET     Z
 2472 F6DB  CD F55E             CALL    FCB2HL          ;yes, get its address.
 2473 F6DE  3E E5               LD      A,0E5H
 2474 F6E0  BE                  CP      (HL)            ;empty file entry?
 2475 F6E1  CA F6D2             JP      Z,BITMAP2
 2476 F6E4  3A F341             LD      A,(USERNO)      ;no, correct user number?
 2477 F6E7  BE                  CP      (HL)
 2478 F6E8  C2 F6F6             JP      NZ,BITMAP3
 2479 F6EB  23                  INC     HL
 2480 F6EC  7E                  LD      A,(HL)          ;yes, does name start with a '$'?
 2481 F6ED  D6 24               SUB     '$'
 2482 F6EF  C2 F6F6             JP      NZ,BITMAP3
 2483 F6F2  3D                  DEC     A               ;yes, set atatus to minus one.
 2484 F6F3  32 F345             LD      (STATUS),A
 2485 F6F6  0E 01       BITMAP3:LD      C,1             ;now set this file's space as used in bit map.
 2486 F6F8  CD F66B             CALL    SETFILE
 2487 F6FB  CD F58C             CALL    CHKNMBR         ;keep (SCRATCH1) in bounds.
 2488 F6FE  C3 F6D2             JP      BITMAP2
 2489                   ;
 2490                   ;   Set the status (STATUS) and return.
 2491                   ;
 2492 F701  3A FDD4     STSTATUS: LD    A,(FNDSTAT)
 2493 F704  C3 F301             JP      SETSTAT
 2494                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  44
BDOS22  Z80

 2495                   ;   Check extents in (A) and (C). Set the zero flag if they
 2496                   ; are the same. The number of 16k chunks of disk space that
 2497                   ; the directory extent covers is expressad is (EXTMASK+1).
 2498                   ; No registers are modified.
 2499                   ;
 2500 F707  C5          SAMEXT: PUSH    BC
 2501 F708  F5                  PUSH    AF
 2502 F709  3A FDC5             LD      A,(EXTMASK)     ;get extent mask and use it to
 2503 F70C  2F                  CPL                     ;to compare both extent numbers.
 2504 F70D  47                  LD      B,A             ;save resulting mask here.
 2505 F70E  79                  LD      A,C             ;mask first extent and save in (C).
 2506 F70F  A0                  AND     B
 2507 F710  4F                  LD      C,A
 2508 F711  F1                  POP     AF              ;now mask second extent and compare
 2509 F712  A0                  AND     B               ;with the first one.
 2510 F713  91                  SUB     C
 2511 F714  E6 1F               AND     1FH             ;(* only check buts 0-4 *)
 2512 F716  C1                  POP     BC              ;the zero flag is set if they are the same.
 2513 F717  C9                  RET                     ;restore (BC) and return.
 2514                   ;
 2515                   ;   Search for the first occurence of a file name. On entry,
 2516                   ; register (C) should contain the number of bytes of the fcb
 2517                   ; that must match.
 2518                   ;
 2519 F718  3E FF       FINDFST:LD      A,0FFH
 2520 F71A  32 FDD4             LD      (FNDSTAT),A
 2521 F71D  21 FDD8             LD      HL,COUNTER      ;save character count.
 2522 F720  71                  LD      (HL),C
 2523 F721  2A F343             LD      HL,(PARAMS)     ;get filename to match.
 2524 F724  22 FDD9             LD      (SAVEFCB),HL    ;and save.
 2525 F727  CD F5FE             CALL    STFILPOS        ;clear initial file position (set to 0ffffh).
 2526 F72A  CD F3A1             CALL    HOMEDRV         ;home the drive.
 2527                   ;
 2528                   ;   Entry to locate the next occurence of a filename within the
 2529                   ; directory. The disk is not expected to have been changed. If
 2530                   ; it was, then it will be write protected.
 2531                   ;
 2532 F72D  0E 00       FINDNXT:LD      C,0             ;write protect the disk if changed.
 2533 F72F  CD F605             CALL    NXENTRY         ;get next filename entry in directory.
 2534 F732  CD F5F5             CALL    CKFILPOS        ;is file position = 0ffffh?
 2535 F735  CA F794             JP      Z,FNDNXT6       ;yes, exit now then.
 2536 F738  2A FDD9             LD      HL,(SAVEFCB)    ;set (DE) pointing to filename to match.
 2537 F73B  EB                  EX      DE,HL
 2538 F73C  1A                  LD      A,(DE)
 2539 F73D  FE E5               CP      0E5H            ;empty directory entry?
 2540 F73F  CA F74A             JP      Z,FNDNXT1       ;(* are we trying to reserect erased entries? *)
 2541 F742  D5                  PUSH    DE
 2542 F743  CD F57F             CALL    MOREFLS         ;more files in directory?
 2543 F746  D1                  POP     DE
 2544 F747  D2 F794             JP      NC,FNDNXT6      ;no more. Exit now.
 2545 F74A  CD F55E     FNDNXT1:CALL    FCB2HL          ;get address of this fcb in directory.
 2546 F74D  3A FDD8             LD      A,(COUNTER)     ;get number of bytes (characters) to check.
 2547 F750  4F                  LD      C,A
 2548 F751  06 00               LD      B,0             ;initialize byte position counter.
 2549 F753  79          FNDNXT2:LD      A,C             ;are we done with the compare?
 2550 F754  B7                  OR      A
 2551 F755  CA F783             JP      Z,FNDNXT5
 2552 F758  1A                  LD      A,(DE)          ;no, check next byte.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  45
BDOS22  Z80

 2553 F759  FE 3F               CP      '?'             ;don't care about this character?
 2554 F75B  CA F77C             JP      Z,FNDNXT4
 2555 F75E  78                  LD      A,B             ;get bytes position in fcb.
 2556 F75F  FE 0D               CP      13              ;don't care about the thirteenth byte either.
 2557 F761  CA F77C             JP      Z,FNDNXT4
 2558 F764  FE 0C               CP      12              ;extent byte?
 2559 F766  1A                  LD      A,(DE)
 2560 F767  CA F773             JP      Z,FNDNXT3
 2561 F76A  96                  SUB     (HL)            ;otherwise compare characters.
 2562 F76B  E6 7F               AND     7FH
 2563 F76D  C2 F72D             JP      NZ,FINDNXT      ;not the same, check next entry.
 2564 F770  C3 F77C             JP      FNDNXT4         ;so far so good, keep checking.
 2565 F773  C5          FNDNXT3:PUSH    BC              ;check the extent byte here.
 2566 F774  4E                  LD      C,(HL)
 2567 F775  CD F707             CALL    SAMEXT
 2568 F778  C1                  POP     BC
 2569 F779  C2 F72D             JP      NZ,FINDNXT      ;not the same, look some more.
 2570                   ;
 2571                   ;   So far the names compare. Bump pointers to the next byte
 2572                   ; and continue until all (C) characters have been checked.
 2573                   ;
 2574 F77C  13          FNDNXT4:INC     DE              ;bump pointers.
 2575 F77D  23                  INC     HL
 2576 F77E  04                  INC     B
 2577 F77F  0D                  DEC     C               ;adjust character counter.
 2578 F780  C3 F753             JP      FNDNXT2
 2579 F783  3A FDEA     FNDNXT5:LD      A,(FILEPOS)     ;return the position of this entry.
 2580 F786  E6 03               AND     03H
 2581 F788  32 F345             LD      (STATUS),A
 2582 F78B  21 FDD4             LD      HL,FNDSTAT
 2583 F78E  7E                  LD      A,(HL)
 2584 F78F  17                  RLA     
 2585 F790  D0                  RET     NC
 2586 F791  AF                  XOR     A
 2587 F792  77                  LD      (HL),A
 2588 F793  C9                  RET     
 2589                   ;
 2590                   ;   Filename was not found. Set appropriate status.
 2591                   ;
 2592 F794  CD F5FE     FNDNXT6:CALL    STFILPOS        ;set (FILEPOS) to 0ffffh.
 2593 F797  3E FF               LD      A,0FFH          ;say not located.
 2594 F799  C3 F301             JP      SETSTAT
 2595                   ;
 2596                   ;   Erase files from the directory. Only the first byte of the
 2597                   ; fcb will be affected. It is set to (E5).
 2598                   ;
 2599 F79C  CD F554     ERAFILE:CALL    CHKWPRT         ;is disk write protected?
 2600 F79F  0E 0C               LD      C,12            ;only compare file names.
 2601 F7A1  CD F718             CALL    FINDFST         ;get first file name.
 2602 F7A4  CD F5F5     ERAFIL1:CALL    CKFILPOS        ;any found?
 2603 F7A7  C8                  RET     Z               ;nope, we must be done.
 2604 F7A8  CD F544             CALL    CHKROFL         ;is file read only?
 2605 F7AB  CD F55E             CALL    FCB2HL          ;nope, get address of fcb and
 2606 F7AE  36 E5               LD      (HL),0E5H       ;set first byte to 'empty'.
 2607 F7B0  0E 00               LD      C,0             ;clear the space from the bit map.
 2608 F7B2  CD F66B             CALL    SETFILE
 2609 F7B5  CD F5C6             CALL    DIRWRITE        ;now write the directory sector back out.
 2610 F7B8  CD F72D             CALL    FINDNXT         ;find the next file name.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  46
BDOS22  Z80

 2611 F7BB  C3 F7A4             JP      ERAFIL1         ;and repeat process.
 2612                   ;
 2613                   ;   Look through the space allocation map (bit map) for the
 2614                   ; next available block. Start searching at block number (BC-1).
 2615                   ; The search procedure is to look for an empty block that is
 2616                   ; before the starting block. If not empty, look at a later
 2617                   ; block number. In this way, we return the closest empty block
 2618                   ; on either side of the 'target' block number. This will speed
 2619                   ; access on random devices. For serial devices, this should be
 2620                   ; changed to look in the forward direction first and then start
 2621                   ; at the front and search some more.
 2622                   ;
 2623                   ;   On return, (DE)= block number that is empty and (HL) =0
 2624                   ; if no empry block was found.
 2625                   ;
 2626 F7BE  50          FNDSPACE: LD    D,B             ;set (DE) as the block that is checked.
 2627 F7BF  59                  LD      E,C
 2628                   ;
 2629                   ;   Look before target block. Registers (BC) are used as the lower
 2630                   ; pointer and (DE) as the upper pointer.
 2631                   ;
 2632 F7C0  79          FNDSPA1:LD      A,C             ;is block 0 specified?
 2633 F7C1  B0                  OR      B
 2634 F7C2  CA F7D1             JP      Z,FNDSPA2
 2635 F7C5  0B                  DEC     BC              ;nope, check previous block.
 2636 F7C6  D5                  PUSH    DE
 2637 F7C7  C5                  PUSH    BC
 2638 F7C8  CD F635             CALL    CKBITMAP
 2639 F7CB  1F                  RRA                     ;is this block empty?
 2640 F7CC  D2 F7EC             JP      NC,FNDSPA3      ;yes. use this.
 2641                   ;
 2642                   ;   Note that the above logic gets the first block that it finds
 2643                   ; that is empty. Thus a file could be written 'backward' making
 2644                   ; it very slow to access. This could be changed to look for the
 2645                   ; first empty block and then continue until the start of this
 2646                   ; empty space is located and then used that starting block.
 2647                   ; This should help speed up access to some files especially on
 2648                   ; a well used disk with lots of fairly small 'holes'.
 2649                   ;
 2650 F7CF  C1                  POP     BC              ;nope, check some more.
 2651 F7D0  D1                  POP     DE
 2652                   ;
 2653                   ;   Now look after target block.
 2654                   ;
 2655 F7D1  2A FDC6     FNDSPA2:LD      HL,(DSKSIZE)    ;is block (DE) within disk limits?
 2656 F7D4  7B                  LD      A,E
 2657 F7D5  95                  SUB     L
 2658 F7D6  7A                  LD      A,D
 2659 F7D7  9C                  SBC     A,H
 2660 F7D8  D2 F7F4             JP      NC,FNDSPA4
 2661 F7DB  13                  INC     DE              ;yes, move on to next one.
 2662 F7DC  C5                  PUSH    BC
 2663 F7DD  D5                  PUSH    DE
 2664 F7DE  42                  LD      B,D
 2665 F7DF  4B                  LD      C,E
 2666 F7E0  CD F635             CALL    CKBITMAP        ;check it.
 2667 F7E3  1F                  RRA                     ;empty?
 2668 F7E4  D2 F7EC             JP      NC,FNDSPA3
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  47
BDOS22  Z80

 2669 F7E7  D1                  POP     DE              ;nope, continue searching.
 2670 F7E8  C1                  POP     BC
 2671 F7E9  C3 F7C0             JP      FNDSPA1
 2672                   ;
 2673                   ;   Empty block found. Set it as used and return with (HL)
 2674                   ; pointing to it (true?).
 2675                   ;
 2676 F7EC  17          FNDSPA3:RLA                     ;reset byte.
 2677 F7ED  3C                  INC     A               ;and set bit 0.
 2678 F7EE  CD F664             CALL    STBMAP1         ;update bit map.
 2679 F7F1  E1                  POP     HL              ;set return registers.
 2680 F7F2  D1                  POP     DE
 2681 F7F3  C9                  RET     
 2682                   ;
 2683                   ;   Free block was not found. If (BC) is not zero, then we have
 2684                   ; not checked all of the disk space.
 2685                   ;
 2686 F7F4  79          FNDSPA4:LD      A,C
 2687 F7F5  B0                  OR      B
 2688 F7F6  C2 F7C0             JP      NZ,FNDSPA1
 2689 F7F9  21 0000             LD      HL,0            ;set 'not found' status.
 2690 F7FC  C9                  RET     
 2691                   ;
 2692                   ;   Move a complete fcb entry into the directory and write it.
 2693                   ;
 2694 F7FD  0E 00       FCBSET: LD      C,0
 2695 F7FF  1E 20               LD      E,32            ;length of each entry.
 2696                   ;
 2697                   ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
 2698                   ; fcb in directory starting at relative byte (C). This updated
 2699                   ; directory buffer is then written to the disk.
 2700                   ;
 2701 F801  D5          UPDATE: PUSH    DE
 2702 F802  06 00               LD      B,0             ;set (BC) to relative byte position.
 2703 F804  2A F343             LD      HL,(PARAMS)     ;get address of fcb.
 2704 F807  09                  ADD     HL,BC           ;compute starting byte.
 2705 F808  EB                  EX      DE,HL
 2706 F809  CD F55E             CALL    FCB2HL          ;get address of fcb to update in directory.
 2707 F80C  C1                  POP     BC              ;set (C) to number of bytes to change.
 2708 F80D  CD F34F             CALL    DE2HL
 2709 F810  CD F3C3     UPDATE1:CALL    TRKSEC          ;determine the track and sector affected.
 2710 F813  C3 F5C6             JP      DIRWRITE        ;then write this sector out.
 2711                   ;
 2712                   ;   Routine to change the name of all files on the disk with a
 2713                   ; specified name. The fcb contains the current name as the
 2714                   ; first 12 characters and the new name 16 bytes into the fcb.
 2715                   ;
 2716 F816  CD F554     CHGNAMES: CALL  CHKWPRT         ;check for a write protected disk.
 2717 F819  0E 0C               LD      C,12            ;match first 12 bytes of fcb only.
 2718 F81B  CD F718             CALL    FINDFST         ;get first name.
 2719 F81E  2A F343             LD      HL,(PARAMS)     ;get address of fcb.
 2720 F821  7E                  LD      A,(HL)          ;get user number.
 2721 F822  11 0010             LD      DE,16           ;move over to desired name.
 2722 F825  19                  ADD     HL,DE
 2723 F826  77                  LD      (HL),A          ;keep same user number.
 2724 F827  CD F5F5     CHGNAM1:CALL    CKFILPOS        ;any matching file found?
 2725 F82A  C8                  RET     Z               ;no, we must be done.
 2726 F82B  CD F544             CALL    CHKROFL         ;check for read only file.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  48
BDOS22  Z80

 2727 F82E  0E 10               LD      C,16            ;start 16 bytes into fcb.
 2728 F830  1E 0C               LD      E,12            ;and update the first 12 bytes of directory.
 2729 F832  CD F801             CALL    UPDATE
 2730 F835  CD F72D             CALL    FINDNXT         ;get te next file name.
 2731 F838  C3 F827             JP      CHGNAM1         ;and continue.
 2732                   ;
 2733                   ;   Update a files attributes. The procedure is to search for
 2734                   ; every file with the same name as shown in fcb (ignoring bit 7)
 2735                   ; and then to update it (which includes bit 7). No other changes
 2736                   ; are made.
 2737                   ;
 2738 F83B  0E 0C       SAVEATTR: LD    C,12            ;match first 12 bytes.
 2739 F83D  CD F718             CALL    FINDFST         ;look for first filename.
 2740 F840  CD F5F5     SAVATR1:CALL    CKFILPOS        ;was one found?
 2741 F843  C8                  RET     Z               ;nope, we must be done.
 2742 F844  0E 00               LD      C,0             ;yes, update the first 12 bytes now.
 2743 F846  1E 0C               LD      E,12
 2744 F848  CD F801             CALL    UPDATE          ;update filename and write directory.
 2745 F84B  CD F72D             CALL    FINDNXT         ;and get the next file.
 2746 F84E  C3 F840             JP      SAVATR1         ;then continue until done.
 2747                   ;
 2748                   ;  Open a file (name specified in fcb).
 2749                   ;
 2750 F851  0E 0F       OPENIT: LD      C,15            ;compare the first 15 bytes.
 2751 F853  CD F718             CALL    FINDFST         ;get the first one in directory.
 2752 F856  CD F5F5             CALL    CKFILPOS        ;any at all?
 2753 F859  C8                  RET     Z
 2754 F85A  CD F4A6     OPENIT1:CALL    SETEXT          ;point to extent byte within users fcb.
 2755 F85D  7E                  LD      A,(HL)          ;and get it.
 2756 F85E  F5                  PUSH    AF              ;save it and address.
 2757 F85F  E5                  PUSH    HL
 2758 F860  CD F55E             CALL    FCB2HL          ;point to fcb in directory.
 2759 F863  EB                  EX      DE,HL
 2760 F864  2A F343             LD      HL,(PARAMS)     ;this is the users copy.
 2761 F867  0E 20               LD      C,32            ;move it into users space.
 2762 F869  D5                  PUSH    DE
 2763 F86A  CD F34F             CALL    DE2HL
 2764 F86D  CD F578             CALL    SETS2B7         ;set bit 7 in 's2' byte (unmodified).
 2765 F870  D1                  POP     DE              ;now get the extent byte from this fcb.
 2766 F871  21 000C             LD      HL,12
 2767 F874  19                  ADD     HL,DE
 2768 F875  4E                  LD      C,(HL)          ;into (C).
 2769 F876  21 000F             LD      HL,15           ;now get the record count byte into (B).
 2770 F879  19                  ADD     HL,DE
 2771 F87A  46                  LD      B,(HL)
 2772 F87B  E1                  POP     HL              ;keep the same extent as the user had originally.
 2773 F87C  F1                  POP     AF
 2774 F87D  77                  LD      (HL),A
 2775 F87E  79                  LD      A,C             ;is it the same as in the directory fcb?
 2776 F87F  BE                  CP      (HL)
 2777 F880  78                  LD      A,B             ;if yes, then use the same record count.
 2778 F881  CA F88B             JP      Z,OPENIT2
 2779 F884  3E 00               LD      A,0             ;if the user specified an extent greater than
 2780 F886  DA F88B             JP      C,OPENIT2       ;the one in the directory, then set record count to 0.
 2781 F889  3E 80               LD      A,128           ;otherwise set to maximum.
 2782 F88B  2A F343     OPENIT2:LD      HL,(PARAMS)     ;set record count in users fcb to (A).
 2783 F88E  11 000F             LD      DE,15
 2784 F891  19                  ADD     HL,DE           ;compute relative position.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  49
BDOS22  Z80

 2785 F892  77                  LD      (HL),A          ;and set the record count.
 2786 F893  C9                  RET     
 2787                   ;
 2788                   ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
 2789                   ; point to a zero value (16 bit).
 2790                   ;   Return with zero flag set it (DE) was moved. Registers (DE)
 2791                   ; and (HL) are not changed. However (A) is.
 2792                   ;
 2793 F894  7E          MOVEWORD: LD    A,(HL)          ;check for a zero word.
 2794 F895  23                  INC     HL
 2795 F896  B6                  OR      (HL)            ;both bytes zero?
 2796 F897  2B                  DEC     HL
 2797 F898  C0                  RET     NZ              ;nope, just return.
 2798 F899  1A                  LD      A,(DE)          ;yes, move two bytes from (DE) into
 2799 F89A  77                  LD      (HL),A          ;this zero space.
 2800 F89B  13                  INC     DE
 2801 F89C  23                  INC     HL
 2802 F89D  1A                  LD      A,(DE)
 2803 F89E  77                  LD      (HL),A
 2804 F89F  1B                  DEC     DE              ;don't disturb these registers.
 2805 F8A0  2B                  DEC     HL
 2806 F8A1  C9                  RET     
 2807                   ;
 2808                   ;   Get here to close a file specified by (fcb).
 2809                   ;
 2810 F8A2  AF          CLOSEIT:XOR     A               ;clear status and file position bytes.
 2811 F8A3  32 F345             LD      (STATUS),A
 2812 F8A6  32 FDEA             LD      (FILEPOS),A
 2813 F8A9  32 FDEB             LD      (FILEPOS+1),A
 2814 F8AC  CD F51E             CALL    GETWPRT         ;get write protect bit for this drive.
 2815 F8AF  C0                  RET     NZ              ;just return if it is set.
 2816 F8B0  CD F569             CALL    GETS2           ;else get the 's2' byte.
 2817 F8B3  E6 80               AND     80H             ;and look at bit 7 (file unmodified?).
 2818 F8B5  C0                  RET     NZ              ;just return if set.
 2819 F8B6  0E 0F               LD      C,15            ;else look up this file in directory.
 2820 F8B8  CD F718             CALL    FINDFST
 2821 F8BB  CD F5F5             CALL    CKFILPOS        ;was it found?
 2822 F8BE  C8                  RET     Z               ;just return if not.
 2823 F8BF  01 0010             LD      BC,16           ;set (HL) pointing to records used section.
 2824 F8C2  CD F55E             CALL    FCB2HL
 2825 F8C5  09                  ADD     HL,BC
 2826 F8C6  EB                  EX      DE,HL
 2827 F8C7  2A F343             LD      HL,(PARAMS)     ;do the same for users specified fcb.
 2828 F8CA  09                  ADD     HL,BC
 2829 F8CB  0E 10               LD      C,16            ;this many bytes are present in this extent.
 2830 F8CD  3A FDDD     CLOSEIT1: LD    A,(BIGDISK)     ;8 or 16 bit record numbers?
 2831 F8D0  B7                  OR      A
 2832 F8D1  CA F8E8             JP      Z,CLOSEIT4
 2833 F8D4  7E                  LD      A,(HL)          ;just 8 bit. Get one from users fcb.
 2834 F8D5  B7                  OR      A
 2835 F8D6  1A                  LD      A,(DE)          ;now get one from directory fcb.
 2836 F8D7  C2 F8DB             JP      NZ,CLOSEIT2
 2837 F8DA  77                  LD      (HL),A          ;users byte was zero. Update from directory.
 2838 F8DB  B7          CLOSEIT2: OR    A
 2839 F8DC  C2 F8E1             JP      NZ,CLOSEIT3
 2840 F8DF  7E                  LD      A,(HL)          ;directories byte was zero, update from users fcb.
 2841 F8E0  12                  LD      (DE),A
 2842 F8E1  BE          CLOSEIT3: CP    (HL)            ;if neither one of these bytes were zero,
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  50
BDOS22  Z80

 2843 F8E2  C2 F91F             JP      NZ,CLOSEIT7     ;then close error if they are not the same.
 2844 F8E5  C3 F8FD             JP      CLOSEIT5        ;ok so far, get to next byte in fcbs.
 2845 F8E8  CD F894     CLOSEIT4: CALL  MOVEWORD        ;update users fcb if it is zero.
 2846 F8EB  EB                  EX      DE,HL
 2847 F8EC  CD F894             CALL    MOVEWORD        ;update directories fcb if it is zero.
 2848 F8EF  EB                  EX      DE,HL
 2849 F8F0  1A                  LD      A,(DE)          ;if these two values are no different,
 2850 F8F1  BE                  CP      (HL)            ;then a close error occured.
 2851 F8F2  C2 F91F             JP      NZ,CLOSEIT7
 2852 F8F5  13                  INC     DE              ;check second byte.
 2853 F8F6  23                  INC     HL
 2854 F8F7  1A                  LD      A,(DE)
 2855 F8F8  BE                  CP      (HL)
 2856 F8F9  C2 F91F             JP      NZ,CLOSEIT7
 2857 F8FC  0D                  DEC     C               ;remember 16 bit values.
 2858 F8FD  13          CLOSEIT5: INC   DE              ;bump to next item in table.
 2859 F8FE  23                  INC     HL
 2860 F8FF  0D                  DEC     C               ;there are 16 entries only.
 2861 F900  C2 F8CD             JP      NZ,CLOSEIT1     ;continue if more to do.
 2862 F903  01 FFEC             LD      BC,0FFECH       ;backup 20 places (extent byte).
 2863 F906  09                  ADD     HL,BC
 2864 F907  EB                  EX      DE,HL
 2865 F908  09                  ADD     HL,BC
 2866 F909  1A                  LD      A,(DE)
 2867 F90A  BE                  CP      (HL)            ;directory's extent already greater than the
 2868 F90B  DA F917             JP      C,CLOSEIT6      ;users extent?
 2869 F90E  77                  LD      (HL),A          ;no, update directory extent.
 2870 F90F  01 0003             LD      BC,3            ;and update the record count byte in
 2871 F912  09                  ADD     HL,BC           ;directories fcb.
 2872 F913  EB                  EX      DE,HL
 2873 F914  09                  ADD     HL,BC
 2874 F915  7E                  LD      A,(HL)          ;get from user.
 2875 F916  12                  LD      (DE),A          ;and put in directory.
 2876 F917  3E FF       CLOSEIT6: LD    A,0FFH          ;set 'was open and is now closed' byte.
 2877 F919  32 FDD2             LD      (CLOSEFLG),A
 2878 F91C  C3 F810             JP      UPDATE1         ;update the directory now.
 2879 F91F  21 F345     CLOSEIT7: LD    HL,STATUS       ;set return status and then return.
 2880 F922  35                  DEC     (HL)
 2881 F923  C9                  RET     
 2882                   ;
 2883                   ;   Routine to get the next empty space in the directory. It
 2884                   ; will then be cleared for use.
 2885                   ;
 2886 F924  CD F554     GETEMPTY: CALL  CHKWPRT         ;make sure disk is not write protected.
 2887 F927  2A F343             LD      HL,(PARAMS)     ;save current parameters (fcb).
 2888 F92A  E5                  PUSH    HL
 2889 F92B  21 FDAC             LD      HL,EMPTYFCB     ;use special one for empty space.
 2890 F92E  22 F343             LD      (PARAMS),HL
 2891 F931  0E 01               LD      C,1             ;search for first empty spot in directory.
 2892 F933  CD F718             CALL    FINDFST         ;(* only check first byte *)
 2893 F936  CD F5F5             CALL    CKFILPOS        ;none?
 2894 F939  E1                  POP     HL
 2895 F93A  22 F343             LD      (PARAMS),HL     ;restore original fcb address.
 2896 F93D  C8                  RET     Z               ;return if no more space.
 2897 F93E  EB                  EX      DE,HL
 2898 F93F  21 000F             LD      HL,15           ;point to number of records for this file.
 2899 F942  19                  ADD     HL,DE
 2900 F943  0E 11               LD      C,17            ;and clear all of this space.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  51
BDOS22  Z80

 2901 F945  AF                  XOR     A
 2902 F946  77          GETMT1: LD      (HL),A
 2903 F947  23                  INC     HL
 2904 F948  0D                  DEC     C
 2905 F949  C2 F946             JP      NZ,GETMT1
 2906 F94C  21 000D             LD      HL,13           ;clear the 's1' byte also.
 2907 F94F  19                  ADD     HL,DE
 2908 F950  77                  LD      (HL),A
 2909 F951  CD F58C             CALL    CHKNMBR         ;keep (SCRATCH1) within bounds.
 2910 F954  CD F7FD             CALL    FCBSET          ;write out this fcb entry to directory.
 2911 F957  C3 F578             JP      SETS2B7         ;set 's2' byte bit 7 (unmodified at present).
 2912                   ;
 2913                   ;   Routine to close the current extent and open the next one
 2914                   ; for reading.
 2915                   ;
 2916 F95A  AF          GETNEXT:XOR     A
 2917 F95B  32 FDD2             LD      (CLOSEFLG),A    ;clear close flag.
 2918 F95E  CD F8A2             CALL    CLOSEIT         ;close this extent.
 2919 F961  CD F5F5             CALL    CKFILPOS
 2920 F964  C8                  RET     Z               ;not there???
 2921 F965  2A F343             LD      HL,(PARAMS)     ;get extent byte.
 2922 F968  01 000C             LD      BC,12
 2923 F96B  09                  ADD     HL,BC
 2924 F96C  7E                  LD      A,(HL)          ;and increment it.
 2925 F96D  3C                  INC     A
 2926 F96E  E6 1F               AND     1FH             ;keep within range 0-31.
 2927 F970  77                  LD      (HL),A
 2928 F971  CA F983             JP      Z,GTNEXT1       ;overflow?
 2929 F974  47                  LD      B,A             ;mask extent byte.
 2930 F975  3A FDC5             LD      A,(EXTMASK)
 2931 F978  A0                  AND     B
 2932 F979  21 FDD2             LD      HL,CLOSEFLG     ;check close flag (0ffh is ok).
 2933 F97C  A6                  AND     (HL)
 2934 F97D  CA F98E             JP      Z,GTNEXT2       ;if zero, we must read in next extent.
 2935 F980  C3 F9AC             JP      GTNEXT3         ;else, it is already in memory.
 2936 F983  01 0002     GTNEXT1:LD      BC,2            ;Point to the 's2' byte.
 2937 F986  09                  ADD     HL,BC
 2938 F987  34                  INC     (HL)            ;and bump it.
 2939 F988  7E                  LD      A,(HL)          ;too many extents?
 2940 F989  E6 0F               AND     0FH
 2941 F98B  CA F9B6             JP      Z,GTNEXT5       ;yes, set error code.
 2942                   ;
 2943                   ;   Get here to open the next extent.
 2944                   ;
 2945 F98E  0E 0F       GTNEXT2:LD      C,15            ;set to check first 15 bytes of fcb.
 2946 F990  CD F718             CALL    FINDFST         ;find the first one.
 2947 F993  CD F5F5             CALL    CKFILPOS        ;none available?
 2948 F996  C2 F9AC             JP      NZ,GTNEXT3
 2949 F999  3A FDD3             LD      A,(RDWRTFLG)    ;no extent present. Can we open an empty one?
 2950 F99C  3C                  INC     A               ;0ffh means reading (so not possible).
 2951 F99D  CA F9B6             JP      Z,GTNEXT5       ;or an error.
 2952 F9A0  CD F924             CALL    GETEMPTY        ;we are writing, get an empty entry.
 2953 F9A3  CD F5F5             CALL    CKFILPOS        ;none?
 2954 F9A6  CA F9B6             JP      Z,GTNEXT5       ;error if true.
 2955 F9A9  C3 F9AF             JP      GTNEXT4         ;else we are almost done.
 2956 F9AC  CD F85A     GTNEXT3:CALL    OPENIT1         ;open this extent.
 2957 F9AF  CD F4BB     GTNEXT4:CALL    STRDATA         ;move in updated data (rec #, extent #, etc.)
 2958 F9B2  AF                  XOR     A               ;clear status and return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  52
BDOS22  Z80

 2959 F9B3  C3 F301             JP      SETSTAT
 2960                   ;
 2961                   ;   Error in extending the file. Too many extents were needed
 2962                   ; or not enough space on the disk.
 2963                   ;
 2964 F9B6  CD F305     GTNEXT5:CALL    IOERR1          ;set error code, clear bit 7 of 's2'
 2965 F9B9  C3 F578             JP      SETS2B7         ;so this is not written on a close.
 2966                   ;
 2967                   ;   Read a sequential file.
 2968                   ;
 2969 F9BC  3E 01       RDSEQ:  LD      A,1             ;set sequential access mode.
 2970 F9BE  32 FDD5             LD      (MODE),A
 2971 F9C1  3E FF       RDSEQ1: LD      A,0FFH          ;don't allow reading unwritten space.
 2972 F9C3  32 FDD3             LD      (RDWRTFLG),A
 2973 F9C6  CD F4BB             CALL    STRDATA         ;put rec# and ext# into fcb.
 2974 F9C9  3A FDE3             LD      A,(SAVNREC)     ;get next record to read.
 2975 F9CC  21 FDE1             LD      HL,SAVNXT       ;get number of records in extent.
 2976 F9CF  BE                  CP      (HL)            ;within this extent?
 2977 F9D0  DA F9E6             JP      C,RDSEQ2
 2978 F9D3  FE 80               CP      128             ;no. Is this extent fully used?
 2979 F9D5  C2 F9FB             JP      NZ,RDSEQ3       ;no. End-of-file.
 2980 F9D8  CD F95A             CALL    GETNEXT         ;yes, open the next one.
 2981 F9DB  AF                  XOR     A               ;reset next record to read.
 2982 F9DC  32 FDE3             LD      (SAVNREC),A
 2983 F9DF  3A F345             LD      A,(STATUS)      ;check on open, successful?
 2984 F9E2  B7                  OR      A
 2985 F9E3  C2 F9FB             JP      NZ,RDSEQ3       ;no, error.
 2986 F9E6  CD F477     RDSEQ2: CALL    COMBLK          ;ok. compute block number to read.
 2987 F9E9  CD F484             CALL    CHKBLK          ;check it. Within bounds?
 2988 F9EC  CA F9FB             JP      Z,RDSEQ3        ;no, error.
 2989 F9EF  CD F48A             CALL    LOGICAL         ;convert (BLKNMBR) to logical sector (128 byte).
 2990 F9F2  CD F3D1             CALL    TRKSEC1         ;set the track and sector for this block #.
 2991 F9F5  CD F3B2             CALL    DOREAD          ;and read it.
 2992 F9F8  C3 F4D2             JP      SETNREC         ;and set the next record to be accessed.
 2993                   ;
 2994                   ;   Read error occured. Set status and return.
 2995                   ;
 2996 F9FB  C3 F305     RDSEQ3: JP      IOERR1
 2997                   ;
 2998                   ;   Write the next sequential record.
 2999                   ;
 3000 F9FE  3E 01       WTSEQ:  LD      A,1             ;set sequential access mode.
 3001 FA00  32 FDD5             LD      (MODE),A
 3002 FA03  3E 00       WTSEQ1: LD      A,0             ;allow an addition empty extent to be opened.
 3003 FA05  32 FDD3             LD      (RDWRTFLG),A
 3004 FA08  CD F554             CALL    CHKWPRT         ;check write protect status.
 3005 FA0B  2A F343             LD      HL,(PARAMS)
 3006 FA0E  CD F547             CALL    CKROF1          ;check for read only file, (HL) already set to fcb.
 3007 FA11  CD F4BB             CALL    STRDATA         ;put updated data into fcb.
 3008 FA14  3A FDE3             LD      A,(SAVNREC)     ;get record number to write.
 3009 FA17  FE 80               CP      128             ;within range?
 3010 FA19  D2 F305             JP      NC,IOERR1       ;no, error(?).
 3011 FA1C  CD F477             CALL    COMBLK          ;compute block number.
 3012 FA1F  CD F484             CALL    CHKBLK          ;check number.
 3013 FA22  0E 00               LD      C,0             ;is there one to write to?
 3014 FA24  C2 FA6E             JP      NZ,WTSEQ6       ;yes, go do it.
 3015 FA27  CD F43E             CALL    GETBLOCK        ;get next block number within fcb to use.
 3016 FA2A  32 FDD7             LD      (RELBLOCK),A    ;and save.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  53
BDOS22  Z80

 3017 FA2D  01 0000             LD      BC,0            ;start looking for space from the start
 3018 FA30  B7                  OR      A               ;if none allocated as yet.
 3019 FA31  CA FA3B             JP      Z,WTSEQ2
 3020 FA34  4F                  LD      C,A             ;extract previous block number from fcb
 3021 FA35  0B                  DEC     BC              ;so we can be closest to it.
 3022 FA36  CD F45E             CALL    EXTBLK
 3023 FA39  44                  LD      B,H
 3024 FA3A  4D                  LD      C,L
 3025 FA3B  CD F7BE     WTSEQ2: CALL    FNDSPACE        ;find the next empty block nearest number (BC).
 3026 FA3E  7D                  LD      A,L             ;check for a zero number.
 3027 FA3F  B4                  OR      H
 3028 FA40  C2 FA48             JP      NZ,WTSEQ3
 3029 FA43  3E 02               LD      A,2             ;no more space?
 3030 FA45  C3 F301             JP      SETSTAT
 3031 FA48  22 FDE5     WTSEQ3: LD      (BLKNMBR),HL    ;save block number to access.
 3032 FA4B  EB                  EX      DE,HL           ;put block number into (DE).
 3033 FA4C  2A F343             LD      HL,(PARAMS)     ;now we must update the fcb for this
 3034 FA4F  01 0010             LD      BC,16           ;newly allocated block.
 3035 FA52  09                  ADD     HL,BC
 3036 FA53  3A FDDD             LD      A,(BIGDISK)     ;8 or 16 bit block numbers?
 3037 FA56  B7                  OR      A
 3038 FA57  3A FDD7             LD      A,(RELBLOCK)    ;(* update this entry *)
 3039 FA5A  CA FA64             JP      Z,WTSEQ4        ;zero means 16 bit ones.
 3040 FA5D  CD F564             CALL    ADDA2HL         ;(HL)=(HL)+(A)
 3041 FA60  73                  LD      (HL),E          ;store new block number.
 3042 FA61  C3 FA6C             JP      WTSEQ5
 3043 FA64  4F          WTSEQ4: LD      C,A             ;compute spot in this 16 bit table.
 3044 FA65  06 00               LD      B,0
 3045 FA67  09                  ADD     HL,BC
 3046 FA68  09                  ADD     HL,BC
 3047 FA69  73                  LD      (HL),E          ;stuff block number (DE) there.
 3048 FA6A  23                  INC     HL
 3049 FA6B  72                  LD      (HL),D
 3050 FA6C  0E 02       WTSEQ5: LD      C,2             ;set (C) to indicate writing to un-used disk space.
 3051 FA6E  3A F345     WTSEQ6: LD      A,(STATUS)      ;are we ok so far?
 3052 FA71  B7                  OR      A
 3053 FA72  C0                  RET     NZ
 3054 FA73  C5                  PUSH    BC              ;yes, save write flag for bios (register C).
 3055 FA74  CD F48A             CALL    LOGICAL         ;convert (BLKNMBR) over to loical sectors.
 3056 FA77  3A FDD5             LD      A,(MODE)        ;get access mode flag (1=sequential,
 3057 FA7A  3D                  DEC     A               ;0=random, 2=special?).
 3058 FA7B  3D                  DEC     A
 3059 FA7C  C2 FABB             JP      NZ,WTSEQ9
 3060                   ;
 3061                   ;   Special random i/o from function #40. Maybe for M/PM, but the
 3062                   ; current block, if it has not been written to, will be zeroed
 3063                   ; out and then written (reason?).
 3064                   ;
 3065 FA7F  C1                  POP     BC
 3066 FA80  C5                  PUSH    BC
 3067 FA81  79                  LD      A,C             ;get write status flag (2=writing unused space).
 3068 FA82  3D                  DEC     A
 3069 FA83  3D                  DEC     A
 3070 FA84  C2 FABB             JP      NZ,WTSEQ9
 3071 FA87  E5                  PUSH    HL
 3072 FA88  2A FDB9             LD      HL,(DIRBUF)     ;zero out the directory buffer.
 3073 FA8B  57                  LD      D,A             ;note that (A) is zero here.
 3074 FA8C  77          WTSEQ7: LD      (HL),A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  54
BDOS22  Z80

 3075 FA8D  23                  INC     HL
 3076 FA8E  14                  INC     D               ;do 128 bytes.
 3077 FA8F  F2 FA8C             JP      P,WTSEQ7
 3078 FA92  CD F5E0             CALL    DIRDMA          ;tell the bios the dma address for directory access.
 3079 FA95  2A FDE7             LD      HL,(LOGSECT)    ;get sector that starts current block.
 3080 FA98  0E 02               LD      C,2             ;set 'writing to unused space' flag.
 3081 FA9A  22 FDE5     WTSEQ8: LD      (BLKNMBR),HL    ;save sector to write.
 3082 FA9D  C5                  PUSH    BC
 3083 FA9E  CD F3D1             CALL    TRKSEC1         ;determine its track and sector numbers.
 3084 FAA1  C1                  POP     BC
 3085 FAA2  CD F3B8             CALL    DOWRITE         ;now write out 128 bytes of zeros.
 3086 FAA5  2A FDE5             LD      HL,(BLKNMBR)    ;get sector number.
 3087 FAA8  0E 00               LD      C,0             ;set normal write flag.
 3088 FAAA  3A FDC4             LD      A,(BLKMASK)     ;determine if we have written the entire
 3089 FAAD  47                  LD      B,A             ;physical block.
 3090 FAAE  A5                  AND     L
 3091 FAAF  B8                  CP      B
 3092 FAB0  23                  INC     HL              ;prepare for the next one.
 3093 FAB1  C2 FA9A             JP      NZ,WTSEQ8       ;continue until (BLKMASK+1) sectors written.
 3094 FAB4  E1                  POP     HL              ;reset next sector number.
 3095 FAB5  22 FDE5             LD      (BLKNMBR),HL
 3096 FAB8  CD F5DA             CALL    DEFDMA          ;and reset dma address.
 3097                   ;
 3098                   ;   Normal disk write. Set the desired track and sector then
 3099                   ; do the actual write.
 3100                   ;
 3101 FABB  CD F3D1     WTSEQ9: CALL    TRKSEC1         ;determine track and sector for this write.
 3102 FABE  C1                  POP     BC              ;get write status flag.
 3103 FABF  C5                  PUSH    BC
 3104 FAC0  CD F3B8             CALL    DOWRITE         ;and write this out.
 3105 FAC3  C1                  POP     BC
 3106 FAC4  3A FDE3             LD      A,(SAVNREC)     ;get number of records in file.
 3107 FAC7  21 FDE1             LD      HL,SAVNXT       ;get last record written.
 3108 FACA  BE                  CP      (HL)
 3109 FACB  DA FAD2             JP      C,WTSEQ10
 3110 FACE  77                  LD      (HL),A          ;we have to update record count.
 3111 FACF  34                  INC     (HL)
 3112 FAD0  0E 02               LD      C,2
 3113                   ;
 3114                   ;*   This area has been patched to correct disk update problem
 3115                   ;* when using blocking and de-blocking in the BIOS.
 3116                   ;
 3117 FAD2  00          WTSEQ10:NOP                     ;was 'dcr c'
 3118 FAD3  00                  NOP                     ;was 'dcr c'
 3119 FAD4  21 0000             LD      HL,0            ;was 'jnz wtseq99'
 3120                   ;
 3121                   ; *   End of patch.
 3122                   ;
 3123 FAD7  F5                  PUSH    AF
 3124 FAD8  CD F569             CALL    GETS2           ;set 'extent written to' flag.
 3125 FADB  E6 7F               AND     7FH             ;(* clear bit 7 *)
 3126 FADD  77                  LD      (HL),A
 3127 FADE  F1                  POP     AF              ;get record count for this extent.
 3128 FADF  FE 7F       WTSEQ99:CP      127             ;is it full?
 3129 FAE1  C2 FB00             JP      NZ,WTSEQ12
 3130 FAE4  3A FDD5             LD      A,(MODE)        ;yes, are we in sequential mode?
 3131 FAE7  FE 01               CP      1
 3132 FAE9  C2 FB00             JP      NZ,WTSEQ12
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  55
BDOS22  Z80

 3133 FAEC  CD F4D2             CALL    SETNREC         ;yes, set next record number.
 3134 FAEF  CD F95A             CALL    GETNEXT         ;and get next empty space in directory.
 3135 FAF2  21 F345             LD      HL,STATUS       ;ok?
 3136 FAF5  7E                  LD      A,(HL)
 3137 FAF6  B7                  OR      A
 3138 FAF7  C2 FAFE             JP      NZ,WTSEQ11
 3139 FAFA  3D                  DEC     A               ;yes, set record count to -1.
 3140 FAFB  32 FDE3             LD      (SAVNREC),A
 3141 FAFE  36 00       WTSEQ11:LD      (HL),0          ;clear status.
 3142 FB00  C3 F4D2     WTSEQ12:JP      SETNREC         ;set next record to access.
 3143                   ;
 3144                   ;   For random i/o, set the fcb for the desired record number
 3145                   ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
 3146                   ; used as follows:
 3147                   ;
 3148                   ;       fcb+35            fcb+34            fcb+33
 3149                   ;  |     'r-2'      |      'r-1'      |      'r-0'     |
 3150                   ;  |7             0 | 7             0 | 7             0|
 3151                   ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
 3152                   ;  |    overflow   | | extra |  extent   |   record #  |
 3153                   ;  | ______________| |_extent|__number___|_____________|
 3154                   ;                     also 's2'
 3155                   ;
 3156                   ;   On entry, register (C) contains 0ffh if this is a read
 3157                   ; and thus we can not access unwritten disk space. Otherwise,
 3158                   ; another extent will be opened (for writing) if required.
 3159                   ;
 3160 FB03  AF          POSITION: XOR   A               ;set random i/o flag.
 3161 FB04  32 FDD5             LD      (MODE),A
 3162                   ;
 3163                   ;   Special entry (function #40). M/PM ?
 3164                   ;
 3165 FB07  C5          POSITN1:PUSH    BC              ;save read/write flag.
 3166 FB08  2A F343             LD      HL,(PARAMS)     ;get address of fcb.
 3167 FB0B  EB                  EX      DE,HL
 3168 FB0C  21 0021             LD      HL,33           ;now get byte 'r0'.
 3169 FB0F  19                  ADD     HL,DE
 3170 FB10  7E                  LD      A,(HL)
 3171 FB11  E6 7F               AND     7FH             ;keep bits 0-6 for the record number to access.
 3172 FB13  F5                  PUSH    AF
 3173 FB14  7E                  LD      A,(HL)          ;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
 3174 FB15  17                  RLA     
 3175 FB16  23                  INC     HL
 3176 FB17  7E                  LD      A,(HL)
 3177 FB18  17                  RLA     
 3178 FB19  E6 1F               AND     1FH             ;and save this in bits 0-4 of (C).
 3179 FB1B  4F                  LD      C,A             ;this is the extent byte.
 3180 FB1C  7E                  LD      A,(HL)          ;now get the extra extent byte.
 3181 FB1D  1F                  RRA     
 3182 FB1E  1F                  RRA     
 3183 FB1F  1F                  RRA     
 3184 FB20  1F                  RRA     
 3185 FB21  E6 0F               AND     0FH
 3186 FB23  47                  LD      B,A             ;and save it in (B).
 3187 FB24  F1                  POP     AF              ;get record number back to (A).
 3188 FB25  23                  INC     HL              ;check overflow byte 'r2'.
 3189 FB26  6E                  LD      L,(HL)
 3190 FB27  2C                  INC     L
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  56
BDOS22  Z80

 3191 FB28  2D                  DEC     L
 3192 FB29  2E 06               LD      L,6             ;prepare for error.
 3193 FB2B  C2 FB8B             JP      NZ,POSITN5      ;out of disk space error.
 3194 FB2E  21 0020             LD      HL,32           ;store record number into fcb.
 3195 FB31  19                  ADD     HL,DE
 3196 FB32  77                  LD      (HL),A
 3197 FB33  21 000C             LD      HL,12           ;and now check the extent byte.
 3198 FB36  19                  ADD     HL,DE
 3199 FB37  79                  LD      A,C
 3200 FB38  96                  SUB     (HL)            ;same extent as before?
 3201 FB39  C2 FB47             JP      NZ,POSITN2
 3202 FB3C  21 000E             LD      HL,14           ;yes, check extra extent byte 's2' also.
 3203 FB3F  19                  ADD     HL,DE
 3204 FB40  78                  LD      A,B
 3205 FB41  96                  SUB     (HL)
 3206 FB42  E6 7F               AND     7FH
 3207 FB44  CA FB7F             JP      Z,POSITN3       ;same, we are almost done then.
 3208                   ;
 3209                   ;  Get here when another extent is required.
 3210                   ;
 3211 FB47  C5          POSITN2:PUSH    BC
 3212 FB48  D5                  PUSH    DE
 3213 FB49  CD F8A2             CALL    CLOSEIT         ;close current extent.
 3214 FB4C  D1                  POP     DE
 3215 FB4D  C1                  POP     BC
 3216 FB4E  2E 03               LD      L,3             ;prepare for error.
 3217 FB50  3A F345             LD      A,(STATUS)
 3218 FB53  3C                  INC     A
 3219 FB54  CA FB84             JP      Z,POSITN4       ;close error.
 3220 FB57  21 000C             LD      HL,12           ;put desired extent into fcb now.
 3221 FB5A  19                  ADD     HL,DE
 3222 FB5B  71                  LD      (HL),C
 3223 FB5C  21 000E             LD      HL,14           ;and store extra extent byte 's2'.
 3224 FB5F  19                  ADD     HL,DE
 3225 FB60  70                  LD      (HL),B
 3226 FB61  CD F851             CALL    OPENIT          ;try and get this extent.
 3227 FB64  3A F345             LD      A,(STATUS)      ;was it there?
 3228 FB67  3C                  INC     A
 3229 FB68  C2 FB7F             JP      NZ,POSITN3
 3230 FB6B  C1                  POP     BC              ;no. can we create a new one (writing?).
 3231 FB6C  C5                  PUSH    BC
 3232 FB6D  2E 04               LD      L,4             ;prepare for error.
 3233 FB6F  0C                  INC     C
 3234 FB70  CA FB84             JP      Z,POSITN4       ;nope, reading unwritten space error.
 3235 FB73  CD F924             CALL    GETEMPTY        ;yes we can, try to find space.
 3236 FB76  2E 05               LD      L,5             ;prepare for error.
 3237 FB78  3A F345             LD      A,(STATUS)
 3238 FB7B  3C                  INC     A
 3239 FB7C  CA FB84             JP      Z,POSITN4       ;out of space?
 3240                   ;
 3241                   ;   Normal return location. Clear error code and return.
 3242                   ;
 3243 FB7F  C1          POSITN3:POP     BC              ;restore stack.
 3244 FB80  AF                  XOR     A               ;and clear error code byte.
 3245 FB81  C3 F301             JP      SETSTAT
 3246                   ;
 3247                   ;   Error. Set the 's2' byte to indicate this (why?).
 3248                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  57
BDOS22  Z80

 3249 FB84  E5          POSITN4:PUSH    HL
 3250 FB85  CD F569             CALL    GETS2
 3251 FB88  36 C0               LD      (HL),0C0H
 3252 FB8A  E1                  POP     HL
 3253                   ;
 3254                   ;   Return with error code (presently in L).
 3255                   ;
 3256 FB8B  C1          POSITN5:POP     BC
 3257 FB8C  7D                  LD      A,L             ;get error code.
 3258 FB8D  32 F345             LD      (STATUS),A
 3259 FB90  C3 F578             JP      SETS2B7
 3260                   ;
 3261                   ;   Read a random record.
 3262                   ;
 3263 FB93  0E FF       READRAN:LD      C,0FFH          ;set 'read' status.
 3264 FB95  CD FB03             CALL    POSITION        ;position the file to proper record.
 3265 FB98  CC F9C1             CALL    Z,RDSEQ1        ;and read it as usual (if no errors).
 3266 FB9B  C9                  RET     
 3267                   ;
 3268                   ;   Write to a random record.
 3269                   ;
 3270 FB9C  0E 00       WRITERAN: LD    C,0             ;set 'writing' flag.
 3271 FB9E  CD FB03             CALL    POSITION        ;position the file to proper record.
 3272 FBA1  CC FA03             CALL    Z,WTSEQ1        ;and write as usual (if no errors).
 3273 FBA4  C9                  RET     
 3274                   ;
 3275                   ;   Compute the random record number. Enter with (HL) pointing
 3276                   ; to a fcb an (DE) contains a relative location of a record
 3277                   ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
 3278                   ; byte, and (A) the 'r2' byte.
 3279                   ;
 3280                   ;   On return, the zero flag is set if the record is within
 3281                   ; bounds. Otherwise, an overflow occured.
 3282                   ;
 3283 FBA5  EB          COMPRAND: EX    DE,HL           ;save fcb pointer in (DE).
 3284 FBA6  19                  ADD     HL,DE           ;compute relative position of record #.
 3285 FBA7  4E                  LD      C,(HL)          ;get record number into (BC).
 3286 FBA8  06 00               LD      B,0
 3287 FBAA  21 000C             LD      HL,12           ;now get extent.
 3288 FBAD  19                  ADD     HL,DE
 3289 FBAE  7E                  LD      A,(HL)          ;compute (BC)=(record #)+(extent)*128.
 3290 FBAF  0F                  RRCA                    ;move lower bit into bit 7.
 3291 FBB0  E6 80               AND     80H             ;and ignore all other bits.
 3292 FBB2  81                  ADD     A,C             ;add to our record number.
 3293 FBB3  4F                  LD      C,A
 3294 FBB4  3E 00               LD      A,0             ;take care of any carry.
 3295 FBB6  88                  ADC     A,B
 3296 FBB7  47                  LD      B,A
 3297 FBB8  7E                  LD      A,(HL)          ;now get the upper bits of extent into
 3298 FBB9  0F                  RRCA                    ;bit positions 0-3.
 3299 FBBA  E6 0F               AND     0FH             ;and ignore all others.
 3300 FBBC  80                  ADD     A,B             ;add this in to 'r1' byte.
 3301 FBBD  47                  LD      B,A
 3302 FBBE  21 000E             LD      HL,14           ;get the 's2' byte (extra extent).
 3303 FBC1  19                  ADD     HL,DE
 3304 FBC2  7E                  LD      A,(HL)
 3305 FBC3  87                  ADD     A,A             ;and shift it left 4 bits (bits 4-7).
 3306 FBC4  87                  ADD     A,A
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  58
BDOS22  Z80

 3307 FBC5  87                  ADD     A,A
 3308 FBC6  87                  ADD     A,A
 3309 FBC7  F5                  PUSH    AF              ;save carry flag (bit 0 of flag byte).
 3310 FBC8  80                  ADD     A,B             ;now add extra extent into 'r1'.
 3311 FBC9  47                  LD      B,A
 3312 FBCA  F5                  PUSH    AF              ;and save carry (overflow byte 'r2').
 3313 FBCB  E1                  POP     HL              ;bit 0 of (L) is the overflow indicator.
 3314 FBCC  7D                  LD      A,L
 3315 FBCD  E1                  POP     HL              ;and same for first carry flag.
 3316 FBCE  B5                  OR      L               ;either one of these set?
 3317 FBCF  E6 01               AND     01H             ;only check the carry flags.
 3318 FBD1  C9                  RET     
 3319                   ;
 3320                   ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
 3321                   ; reflect the last record used for a random (or other) file.
 3322                   ; This reads the directory and looks at all extents computing
 3323                   ; the largerst record number for each and keeping the maximum
 3324                   ; value only. Then 'r0', 'r1', and 'r2' will reflect this
 3325                   ; maximum record number. This is used to compute the space used
 3326                   ; by a random file.
 3327                   ;
 3328 FBD2  0E 0C       RANSIZE:LD      C,12            ;look thru directory for first entry with
 3329 FBD4  CD F718             CALL    FINDFST         ;this name.
 3330 FBD7  2A F343             LD      HL,(PARAMS)     ;zero out the 'r0, r1, r2' bytes.
 3331 FBDA  11 0021             LD      DE,33
 3332 FBDD  19                  ADD     HL,DE
 3333 FBDE  E5                  PUSH    HL
 3334 FBDF  72                  LD      (HL),D          ;note that (D)=0.
 3335 FBE0  23                  INC     HL
 3336 FBE1  72                  LD      (HL),D
 3337 FBE2  23                  INC     HL
 3338 FBE3  72                  LD      (HL),D
 3339 FBE4  CD F5F5     RANSIZ1:CALL    CKFILPOS        ;is there an extent to process?
 3340 FBE7  CA FC0C             JP      Z,RANSIZ3       ;no, we are done.
 3341 FBEA  CD F55E             CALL    FCB2HL          ;set (HL) pointing to proper fcb in dir.
 3342 FBED  11 000F             LD      DE,15           ;point to last record in extent.
 3343 FBF0  CD FBA5             CALL    COMPRAND        ;and compute random parameters.
 3344 FBF3  E1                  POP     HL
 3345 FBF4  E5                  PUSH    HL              ;now check these values against those
 3346 FBF5  5F                  LD      E,A             ;already in fcb.
 3347 FBF6  79                  LD      A,C             ;the carry flag will be set if those
 3348 FBF7  96                  SUB     (HL)            ;in the fcb represent a larger size than
 3349 FBF8  23                  INC     HL              ;this extent does.
 3350 FBF9  78                  LD      A,B
 3351 FBFA  9E                  SBC     A,(HL)
 3352 FBFB  23                  INC     HL
 3353 FBFC  7B                  LD      A,E
 3354 FBFD  9E                  SBC     A,(HL)
 3355 FBFE  DA FC06             JP      C,RANSIZ2
 3356 FC01  73                  LD      (HL),E          ;we found a larger (in size) extent.
 3357 FC02  2B                  DEC     HL              ;stuff these values into fcb.
 3358 FC03  70                  LD      (HL),B
 3359 FC04  2B                  DEC     HL
 3360 FC05  71                  LD      (HL),C
 3361 FC06  CD F72D     RANSIZ2:CALL    FINDNXT         ;now get the next extent.
 3362 FC09  C3 FBE4             JP      RANSIZ1         ;continue til all done.
 3363 FC0C  E1          RANSIZ3:POP     HL              ;we are done, restore the stack and
 3364 FC0D  C9                  RET                     ;return.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  59
BDOS22  Z80

 3365                   ;
 3366                   ;   Function to return the random record position of a given
 3367                   ; file which has been read in sequential mode up to now.
 3368                   ;
 3369 FC0E  2A F343     SETRAN: LD      HL,(PARAMS)     ;point to fcb.
 3370 FC11  11 0020             LD      DE,32           ;and to last used record.
 3371 FC14  CD FBA5             CALL    COMPRAND        ;compute random position.
 3372 FC17  21 0021             LD      HL,33           ;now stuff these values into fcb.
 3373 FC1A  19                  ADD     HL,DE
 3374 FC1B  71                  LD      (HL),C          ;move 'r0'.
 3375 FC1C  23                  INC     HL
 3376 FC1D  70                  LD      (HL),B          ;and 'r1'.
 3377 FC1E  23                  INC     HL
 3378 FC1F  77                  LD      (HL),A          ;and lastly 'r2'.
 3379 FC20  C9                  RET     
 3380                   ;
 3381                   ;   This routine select the drive specified in (ACTIVE) and
 3382                   ; update the login vector and bitmap table if this drive was
 3383                   ; not already active.
 3384                   ;
 3385 FC21  2A FDAF     LOGINDRV: LD    HL,(LOGIN)      ;get the login vector.
 3386 FC24  3A F342             LD      A,(ACTIVE)      ;get the default drive.
 3387 FC27  4F                  LD      C,A
 3388 FC28  CD F4EA             CALL    SHIFTR          ;position active bit for this drive
 3389 FC2B  E5                  PUSH    HL              ;into bit 0.
 3390 FC2C  EB                  EX      DE,HL
 3391 FC2D  CD F359             CALL    SELECT          ;select this drive.
 3392 FC30  E1                  POP     HL
 3393 FC31  CC F347             CALL    Z,SLCTERR       ;valid drive?
 3394 FC34  7D                  LD      A,L             ;is this a newly activated drive?
 3395 FC35  1F                  RRA     
 3396 FC36  D8                  RET     C
 3397 FC37  2A FDAF             LD      HL,(LOGIN)      ;yes, update the login vector.
 3398 FC3A  4D                  LD      C,L
 3399 FC3B  44                  LD      B,H
 3400 FC3C  CD F50B             CALL    SETBIT
 3401 FC3F  22 FDAF             LD      (LOGIN),HL      ;and save.
 3402 FC42  C3 F6A3             JP      BITMAP          ;now update the bitmap.
 3403                   ;
 3404                   ;   Function to set the active disk number.
 3405                   ;
 3406 FC45  3A FDD6     SETDSK: LD      A,(EPARAM)      ;get parameter passed and see if this
 3407 FC48  21 F342             LD      HL,ACTIVE       ;represents a change in drives.
 3408 FC4B  BE                  CP      (HL)
 3409 FC4C  C8                  RET     Z
 3410 FC4D  77                  LD      (HL),A          ;yes it does, log it in.
 3411 FC4E  C3 FC21             JP      LOGINDRV
 3412                   ;
 3413                   ;   This is the 'auto disk select' routine. The firsst byte
 3414                   ; of the fcb is examined for a drive specification. If non
 3415                   ; zero then the drive will be selected and loged in.
 3416                   ;
 3417 FC51  3E FF       AUTOSEL:LD      A,0FFH          ;say 'auto-select activated'.
 3418 FC53  32 FDDE             LD      (AUTO),A
 3419 FC56  2A F343             LD      HL,(PARAMS)     ;get drive specified.
 3420 FC59  7E                  LD      A,(HL)
 3421 FC5A  E6 1F               AND     1FH             ;look at lower 5 bits.
 3422 FC5C  3D                  DEC     A               ;adjust for (1=A, 2=B) etc.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  60
BDOS22  Z80

 3423 FC5D  32 FDD6             LD      (EPARAM),A      ;and save for the select routine.
 3424 FC60  FE 1E               CP      1EH             ;check for 'no change' condition.
 3425 FC62  D2 FC75             JP      NC,AUTOSL1      ;yes, don't change.
 3426 FC65  3A F342             LD      A,(ACTIVE)      ;we must change, save currently active
 3427 FC68  32 FDDF             LD      (OLDDRV),A      ;drive.
 3428 FC6B  7E                  LD      A,(HL)          ;and save first byte of fcb also.
 3429 FC6C  32 FDE0             LD      (AUTOFLAG),A    ;this must be non-zero.
 3430 FC6F  E6 E0               AND     0E0H            ;whats this for (bits 6,7 are used for
 3431 FC71  77                  LD      (HL),A          ;something)?
 3432 FC72  CD FC45             CALL    SETDSK          ;select and log in this drive.
 3433 FC75  3A F341     AUTOSL1:LD      A,(USERNO)      ;move user number into fcb.
 3434 FC78  2A F343             LD      HL,(PARAMS)     ;(* upper half of first byte *)
 3435 FC7B  B6                  OR      (HL)
 3436 FC7C  77                  LD      (HL),A
 3437 FC7D  C9                  RET                     ;and return (all done).
 3438                   ;
 3439                   ;   Function to return the current cp/m version number.
 3440                   ;
 3441 FC7E  3E 22       GETVER: LD      A,022H          ;version 2.2
 3442 FC80  C3 F301             JP      SETSTAT
 3443                   ;
 3444                   ;   Function to reset the disk system.
 3445                   ;
 3446 FC83  21 0000     RSTDSK: LD      HL,0            ;clear write protect status and log
 3447 FC86  22 FDAD             LD      (WRTPRT),HL     ;in vector.
 3448 FC89  22 FDAF             LD      (LOGIN),HL
 3449 FC8C  AF                  XOR     A               ;select drive 'A'.
 3450 FC8D  32 F342             LD      (ACTIVE),A
 3451 FC90  21 0080             LD      HL,TBUFF        ;setup default dma address.
 3452 FC93  22 FDB1             LD      (USERDMA),HL
 3453 FC96  CD F5DA             CALL    DEFDMA
 3454 FC99  C3 FC21             JP      LOGINDRV        ;now log in drive 'A'.
 3455                   ;
 3456                   ;   Function to open a specified file.
 3457                   ;
 3458 FC9C  CD F572     OPENFIL:CALL    CLEARS2         ;clear 's2' byte.
 3459 FC9F  CD FC51             CALL    AUTOSEL         ;select proper disk.
 3460 FCA2  C3 F851             JP      OPENIT          ;and open the file.
 3461                   ;
 3462                   ;   Function to close a specified file.
 3463                   ;
 3464 FCA5  CD FC51     CLOSEFIL: CALL  AUTOSEL         ;select proper disk.
 3465 FCA8  C3 F8A2             JP      CLOSEIT         ;and close the file.
 3466                   ;
 3467                   ;   Function to return the first occurence of a specified file
 3468                   ; name. If the first byte of the fcb is '?' then the name will
 3469                   ; not be checked (get the first entry no matter what).
 3470                   ;
 3471 FCAB  0E 00       GETFST: LD      C,0             ;prepare for special search.
 3472 FCAD  EB                  EX      DE,HL
 3473 FCAE  7E                  LD      A,(HL)          ;is first byte a '?'?
 3474 FCAF  FE 3F               CP      '?'
 3475 FCB1  CA FCC2             JP      Z,GETFST1       ;yes, just get very first entry (zero length match).
 3476 FCB4  CD F4A6             CALL    SETEXT          ;get the extension byte from fcb.
 3477 FCB7  7E                  LD      A,(HL)          ;is it '?'? if yes, then we want
 3478 FCB8  FE 3F               CP      '?'             ;an entry with a specific 's2' byte.
 3479 FCBA  C4 F572             CALL    NZ,CLEARS2      ;otherwise, look for a zero 's2' byte.
 3480 FCBD  CD FC51             CALL    AUTOSEL         ;select proper drive.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  61
BDOS22  Z80

 3481 FCC0  0E 0F               LD      C,15            ;compare bytes 0-14 in fcb (12&13 excluded).
 3482 FCC2  CD F718     GETFST1:CALL    FINDFST         ;find an entry and then move it into
 3483 FCC5  C3 F5E9             JP      MOVEDIR         ;the users dma space.
 3484                   ;
 3485                   ;   Function to return the next occurence of a file name.
 3486                   ;
 3487 FCC8  2A FDD9     GETNXT: LD      HL,(SAVEFCB)    ;restore pointers. note that no
 3488 FCCB  22 F343             LD      (PARAMS),HL     ;other dbos calls are allowed.
 3489 FCCE  CD FC51             CALL    AUTOSEL         ;no error will be returned, but the
 3490 FCD1  CD F72D             CALL    FINDNXT         ;results will be wrong.
 3491 FCD4  C3 F5E9             JP      MOVEDIR
 3492                   ;
 3493                   ;   Function to delete a file by name.
 3494                   ;
 3495 FCD7  CD FC51     DELFILE:CALL    AUTOSEL         ;select proper drive.
 3496 FCDA  CD F79C             CALL    ERAFILE         ;erase the file.
 3497 FCDD  C3 F701             JP      STSTATUS        ;set status and return.
 3498                   ;
 3499                   ;   Function to execute a sequential read of the specified
 3500                   ; record number.
 3501                   ;
 3502 FCE0  CD FC51     READSEQ:CALL    AUTOSEL         ;select proper drive then read.
 3503 FCE3  C3 F9BC             JP      RDSEQ
 3504                   ;
 3505                   ;   Function to write the net sequential record.
 3506                   ;
 3507 FCE6  CD FC51     WRTSEQ: CALL    AUTOSEL         ;select proper drive then write.
 3508 FCE9  C3 F9FE             JP      WTSEQ
 3509                   ;
 3510                   ;   Create a file function.
 3511                   ;
 3512 FCEC  CD F572     FCREATE:CALL    CLEARS2         ;clear the 's2' byte on all creates.
 3513 FCEF  CD FC51             CALL    AUTOSEL         ;select proper drive and get the next
 3514 FCF2  C3 F924             JP      GETEMPTY        ;empty directory space.
 3515                   ;
 3516                   ;   Function to rename a file.
 3517                   ;
 3518 FCF5  CD FC51     RENFILE:CALL    AUTOSEL         ;select proper drive and then switch
 3519 FCF8  CD F816             CALL    CHGNAMES        ;file names.
 3520 FCFB  C3 F701             JP      STSTATUS
 3521                   ;
 3522                   ;   Function to return the login vector.
 3523                   ;
 3524 FCFE  2A FDAF     GETLOG: LD      HL,(LOGIN)
 3525 FD01  C3 FD29             JP      GETPRM1
 3526                   ;
 3527                   ;   Function to return the current disk assignment.
 3528                   ;
 3529 FD04  3A F342     GETCRNT:LD      A,(ACTIVE)
 3530 FD07  C3 F301             JP      SETSTAT
 3531                   ;
 3532                   ;   Function to set the dma address.
 3533                   ;
 3534 FD0A  EB          PUTDMA: EX      DE,HL
 3535 FD0B  22 FDB1             LD      (USERDMA),HL    ;save in our space and then get to
 3536 FD0E  C3 F5DA             JP      DEFDMA          ;the bios with this also.
 3537                   ;
 3538                   ;   Function to return the allocation vector.
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  62
BDOS22  Z80

 3539                   ;
 3540 FD11  2A FDBF     GETALOC:LD      HL,(ALOCVECT)
 3541 FD14  C3 FD29             JP      GETPRM1
 3542                   ;
 3543                   ;   Function to return the read-only status vector.
 3544                   ;
 3545 FD17  2A FDAD     GETROV: LD      HL,(WRTPRT)
 3546 FD1A  C3 FD29             JP      GETPRM1
 3547                   ;
 3548                   ;   Function to set the file attributes (read-only, system).
 3549                   ;
 3550 FD1D  CD FC51     SETATTR:CALL    AUTOSEL         ;select proper drive then save attributes.
 3551 FD20  CD F83B             CALL    SAVEATTR
 3552 FD23  C3 F701             JP      STSTATUS
 3553                   ;
 3554                   ;   Function to return the address of the disk parameter block
 3555                   ; for the current drive.
 3556                   ;
 3557 FD26  2A FDBB     GETPARM:LD      HL,(DISKPB)
 3558 FD29  22 F345     GETPRM1:LD      (STATUS),HL
 3559 FD2C  C9                  RET     
 3560                   ;
 3561                   ;   Function to get or set the user number. If (E) was (FF)
 3562                   ; then this is a request to return the current user number.
 3563                   ; Else set the user number from (E).
 3564                   ;
 3565 FD2D  3A FDD6     GETUSER:LD      A,(EPARAM)      ;get parameter.
 3566 FD30  FE FF               CP      0FFH            ;get user number?
 3567 FD32  C2 FD3B             JP      NZ,SETUSER
 3568 FD35  3A F341             LD      A,(USERNO)      ;yes, just do it.
 3569 FD38  C3 F301             JP      SETSTAT
 3570 FD3B  E6 1F       SETUSER:AND     1FH             ;no, we should set it instead. keep low
 3571 FD3D  32 F341             LD      (USERNO),A      ;bits (0-4) only.
 3572 FD40  C9                  RET     
 3573                   ;
 3574                   ;   Function to read a random record from a file.
 3575                   ;
 3576 FD41  CD FC51     RDRANDOM: CALL  AUTOSEL         ;select proper drive and read.
 3577 FD44  C3 FB93             JP      READRAN
 3578                   ;
 3579                   ;   Function to compute the file size for random files.
 3580                   ;
 3581 FD47  CD FC51     WTRANDOM: CALL  AUTOSEL         ;select proper drive and write.
 3582 FD4A  C3 FB9C             JP      WRITERAN
 3583                   ;
 3584                   ;   Function to compute the size of a random file.
 3585                   ;
 3586 FD4D  CD FC51     FILESIZE: CALL  AUTOSEL         ;select proper drive and check file length
 3587 FD50  C3 FBD2             JP      RANSIZE
 3588                   ;
 3589                   ;   Function #37. This allows a program to log off any drives.
 3590                   ; On entry, set (DE) to contain a word with bits set for those
 3591                   ; drives that are to be logged off. The log-in vector and the
 3592                   ; write protect vector will be updated. This must be a M/PM
 3593                   ; special function.
 3594                   ;
 3595 FD53  2A F343     LOGOFF: LD      HL,(PARAMS)     ;get drives to log off.
 3596 FD56  7D                  LD      A,L             ;for each bit that is set, we want
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  63
BDOS22  Z80

 3597 FD57  2F                  CPL                     ;to clear that bit in (LOGIN)
 3598 FD58  5F                  LD      E,A             ;and (WRTPRT).
 3599 FD59  7C                  LD      A,H
 3600 FD5A  2F                  CPL     
 3601 FD5B  2A FDAF             LD      HL,(LOGIN)      ;reset the login vector.
 3602 FD5E  A4                  AND     H
 3603 FD5F  57                  LD      D,A
 3604 FD60  7D                  LD      A,L
 3605 FD61  A3                  AND     E
 3606 FD62  5F                  LD      E,A
 3607 FD63  2A FDAD             LD      HL,(WRTPRT)
 3608 FD66  EB                  EX      DE,HL
 3609 FD67  22 FDAF             LD      (LOGIN),HL      ;and save.
 3610 FD6A  7D                  LD      A,L             ;now do the write protect vector.
 3611 FD6B  A3                  AND     E
 3612 FD6C  6F                  LD      L,A
 3613 FD6D  7C                  LD      A,H
 3614 FD6E  A2                  AND     D
 3615 FD6F  67                  LD      H,A
 3616 FD70  22 FDAD             LD      (WRTPRT),HL     ;and save. all done.
 3617 FD73  C9                  RET     
 3618                   ;
 3619                   ;   Get here to return to the user.
 3620                   ;
 3621 FD74  3A FDDE     GOBACK: LD      A,(AUTO)        ;was auto select activated?
 3622 FD77  B7                  OR      A
 3623 FD78  CA FD91             JP      Z,GOBACK1
 3624 FD7B  2A F343             LD      HL,(PARAMS)     ;yes, but was a change made?
 3625 FD7E  36 00               LD      (HL),0          ;(* reset first byte of fcb *)
 3626 FD80  3A FDE0             LD      A,(AUTOFLAG)
 3627 FD83  B7                  OR      A
 3628 FD84  CA FD91             JP      Z,GOBACK1
 3629 FD87  77                  LD      (HL),A          ;yes, reset first byte properly.
 3630 FD88  3A FDDF             LD      A,(OLDDRV)      ;and get the old drive and select it.
 3631 FD8B  32 FDD6             LD      (EPARAM),A
 3632 FD8E  CD FC45             CALL    SETDSK
 3633 FD91  2A F30F     GOBACK1:LD      HL,(USRSTACK)   ;reset the users stack pointer.
 3634 FD94  F9                  LD      SP,HL
 3635 FD95  2A F345             LD      HL,(STATUS)     ;get return status.
 3636 FD98  7D                  LD      A,L             ;force version 1.4 compatability.
 3637 FD99  44                  LD      B,H
 3638 FD9A  C9                  RET                     ;and go back to user.
 3639                   ;
 3640                   ;   Function #40. This is a special entry to do random i/o.
 3641                   ; For the case where we are writing to unused disk space, this
 3642                   ; space will be zeroed out first. This must be a M/PM special
 3643                   ; purpose function, because why would any normal program even
 3644                   ; care about the previous contents of a sector about to be
 3645                   ; written over.
 3646                   ;
 3647 FD9B  CD FC51     WTSPECL:CALL    AUTOSEL         ;select proper drive.
 3648 FD9E  3E 02               LD      A,2             ;use special write mode.
 3649 FDA0  32 FDD5             LD      (MODE),A
 3650 FDA3  0E 00               LD      C,0             ;set write indicator.
 3651 FDA5  CD FB07             CALL    POSITN1         ;position the file.
 3652 FDA8  CC FA03             CALL    Z,WTSEQ1        ;and write (if no errors).
 3653 FDAB  C9                  RET     
 3654                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  64
BDOS22  Z80

 3655                   ;**************************************************************
 3656                   ;*
 3657                   ;*     BDOS data storage pool.
 3658                   ;*
 3659                   ;**************************************************************
 3660                   ;
 3661 FDAC  E5          EMPTYFCB:  DB   0E5H            ;empty directory segment indicator.
 3662 FDAD  0000        WRTPRT:  DW     0               ;write protect status for all 16 drives.
 3663 FDAF  0000        LOGIN:   DW     0               ;drive active word (1 bit per drive).
 3664 FDB1  0080        USERDMA: DW     080H            ;user's dma address (defaults to 80h).
 3665                   ;
 3666                   ;   Scratch areas from parameter block.
 3667                   ;
 3668 FDB3  0000        SCRATCH1:  DW   0               ;relative position within dir segment for file (0-3).
 3669 FDB5  0000        SCRATCH2:  DW   0               ;last selected track number.
 3670 FDB7  0000        SCRATCH3:  DW   0               ;last selected sector number.
 3671                   ;
 3672                   ;   Disk storage areas from parameter block.
 3673                   ;
 3674 FDB9  0000        DIRBUF:  DW     0               ;address of directory buffer to use.
 3675 FDBB  0000        DISKPB:  DW     0               ;contains address of disk parameter block.
 3676 FDBD  0000        CHKVECT: DW     0               ;address of check vector.
 3677 FDBF  0000        ALOCVECT:  DW   0               ;address of allocation vector (bit map).
 3678                   ;
 3679                   ;   Parameter block returned from the bios.
 3680                   ;
 3681 FDC1  0000        SECTORS: DW     0               ;sectors per track from bios.
 3682 FDC3  00          BLKSHFT: DB     0               ;block shift.
 3683 FDC4  00          BLKMASK: DB     0               ;block mask.
 3684 FDC5  00          EXTMASK: DB     0               ;extent mask.
 3685 FDC6  0000        DSKSIZE: DW     0               ;disk size from bios (number of blocks-1).
 3686 FDC8  0000        DIRSIZE: DW     0               ;directory size.
 3687 FDCA  0000        ALLOC0:  DW     0               ;storage for first bytes of bit map (dir space used).
 3688 FDCC  0000        ALLOC1:  DW     0
 3689 FDCE  0000        OFFSET:  DW     0               ;first usable track number.
 3690 FDD0  0000        XLATE:   DW     0               ;sector translation table address.
 3691                   ;
 3692                   ;
 3693 FDD2  00          CLOSEFLG:  DB   0               ;close flag (=0ffh is extent written ok).
 3694 FDD3  00          RDWRTFLG:  DB   0               ;read/write flag (0ffh=read, 0=write).
 3695 FDD4  00          FNDSTAT: DB     0               ;filename found status (0=found first entry).
 3696 FDD5  00          MODE:    DB     0               ;I/o mode select (0=random, 1=sequential, 2=special random).
 3697 FDD6  00          EPARAM:  DB     0               ;storage for register (E) on entry to bdos.
 3698 FDD7  00          RELBLOCK:  DB   0               ;relative position within fcb of block number written.
 3699 FDD8  00          COUNTER: DB     0               ;byte counter for directory name searches.
 3700 FDD9  0000  0000  SAVEFCB: DW     0,0             ;save space for address of fcb (for directory searches).
 3701 FDDD  00          BIGDISK: DB     0               ;if =0 then disk is > 256 blocks long.
 3702 FDDE  00          AUTO:    DB     0               ;if non-zero, then auto select activated.
 3703 FDDF  00          OLDDRV:  DB     0               ;on auto select, storage for previous drive.
 3704 FDE0  00          AUTOFLAG:  DB   0               ;if non-zero, then auto select changed drives.
 3705 FDE1  00          SAVNXT:  DB     0               ;storage for next record number to access.
 3706 FDE2  00          SAVEXT:  DB     0               ;storage for extent number of file.
 3707 FDE3  0000        SAVNREC: DW     0               ;storage for number of records in file.
 3708 FDE5  0000        BLKNMBR: DW     0               ;block number (physical sector) used within a file or logical sect
 3709 FDE7  0000        LOGSECT: DW     0               ;starting logical (128 byte) sector of block (physical sector).
 3710 FDE9  00          FCBPOS:  DB     0               ;relative position within buffer for fcb of file of interest.
 3711 FDEA  0000        FILEPOS: DW     0               ;files position within directory (0 to max entries -1).
 3712                   ;
Z80ASM SuperFast Relocating Macro Assembler     	    Z80ASM 1.32 Page  65
BDOS22  Z80

 3713                   ;   Disk directory buffer checksum bytes. One for each of the
 3714                   ; 16 possible drives.
 3715                   ;
 3716 FDEC  00 00 00 00 CKSUMTBL:  DB   0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 3717                   ;
 3718                   ;   Extra space ?
 3719                   ;
 3720 FDFC  00 00 00 00          DB     0,0,0,0
 3721                   ;
 3722                   ;**************************************************************
 3723                   ;*
 3724                   ;*        B I O S   J U M P   T A B L E
 3725                   ;*
 3726                   ;**************************************************************
 3727                   ;
 3728         FE00      BOOT:    EQU $+0
 3729         FE03      WBOOT:   EQU $+3
 3730         FE06      CONST:   EQU $+6
 3731         FE09      CONIN:   EQU $+9
 3732         FE0C      CONOUT:  EQU $+12
 3733         FE0F      LIST:    EQU $+15
 3734         FE12      PUNCH:   EQU $+18
 3735         FE15      READER:  EQU $+21
 3736         FE18      HOME:    EQU $+24
 3737         FE1B      SELDSK:  EQU $+27
 3738         FE1E      SETTRK:  EQU $+30
 3739         FE21      SETSEC:  EQU $+33
 3740         FE24      SETDMA:  EQU $+36
 3741         FE27      READ:    EQU $+39
 3742         FE2A      WRITE:   EQU $+42
 3743         FE2D      PRSTAT:  EQU $+45
 3744         FE30      SECTRN:  EQU $+48
 3745                   ;
 3746                   ;*
 3747                   ;******************   E N D   O F   C P / M   *****************
 3748                   ;*
 3749                            END
 0 Error(s) Detected.
 5632 Absolute Bytes. 499 Symbols Detected.
